{
  "metadata": {
    "week": 9,
    "title": "Session Layer and Presentation Layer",
    "version": "1.0.0",
    "author": "ing. dr. Antonio Clim",
    "estimated_time_minutes": 15,
    "passing_score_percent": 70,
    "total_questions": 15,
    "bloom_levels_covered": [
      "remember",
      "understand",
      "apply",
      "analyse"
    ],
    "learning_objectives_covered": [
      "LO1",
      "LO2",
      "LO3",
      "LO4",
      "LO5",
      "LO6"
    ]
  },
  "questions": [
    {
      "id": "q01",
      "lo_ref": "LO1",
      "bloom_level": "remember",
      "difficulty": "basic",
      "type": "multiple_choice",
      "stem": "Which layer of the OSI model is responsible for managing dialogue control,\nauthentication state and session checkpoints?\n",
      "options": {
        "a": "Layer 4 (Transport)",
        "b": "Layer 5 (Session)",
        "c": "Layer 6 (Presentation)",
        "d": "Layer 7 (Application)"
      },
      "correct": "b",
      "explanation": "The Session Layer (L5) manages logical dialogues between applications,\nincluding authentication, checkpointing and dialogue control (half/full-duplex).\nTransport (L4) handles reliable delivery; Presentation (L6) handles encoding.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-1",
      "time_seconds": 45
    },
    {
      "id": "q02",
      "lo_ref": "LO1",
      "bloom_level": "understand",
      "difficulty": "intermediate",
      "type": "multiple_choice",
      "stem": "A user is logged into an FTP server. The network cable is unplugged for\n30 seconds, causing the TCP connection to drop. When reconnected, what\nhappens to the FTP session state?\n",
      "options": {
        "a": "Session is preserved — TCP handles reconnection transparently",
        "b": "Session is lost — user must re-authenticate with USER/PASS",
        "c": "Session is cached — server remembers for 5 minutes by default",
        "d": "Session is partially preserved — authentication kept, directory reset"
      },
      "correct": "b",
      "explanation": "FTP session state (authentication, current directory) is tied to the TCP\nconnection. When TCP drops, the session is lost entirely. Unlike HTTP with\ncookies, standard FTP has no session persistence mechanism.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-1",
      "time_seconds": 60
    },
    {
      "id": "q03",
      "lo_ref": "LO2",
      "bloom_level": "remember",
      "difficulty": "basic",
      "type": "multiple_choice",
      "stem": "In network byte order (big-endian), how is the 32-bit integer 0x12345678\nstored in memory, starting from the lowest address?\n",
      "options": {
        "a": "78 56 34 12 (LSB first)",
        "b": "12 34 56 78 (MSB first)",
        "c": "21 43 65 87 (nibble-swapped)",
        "d": "87 65 43 21 (fully reversed)"
      },
      "correct": "b",
      "explanation": "Big-endian (network byte order) stores the Most Significant Byte (MSB) at\nthe lowest address. 0x12 is the MSB, so it comes first. Little-endian (x86)\nwould store 78 56 34 12.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-5",
      "time_seconds": 45
    },
    {
      "id": "q04",
      "lo_ref": "LO2",
      "bloom_level": "apply",
      "difficulty": "intermediate",
      "type": "fill_blank",
      "stem": "Complete the Python struct format string to pack a 32-bit unsigned integer\nin network byte order: struct.pack(\"___\", value)\n",
      "correct": [
        ">I",
        "!I"
      ],
      "hint": "Use '>' or '!' for big-endian, 'I' for unsigned 32-bit integer",
      "explanation": "The format string \">I\" or \"!I\" specifies big-endian (network) byte order\nwith an unsigned 32-bit integer. The '!' is explicitly \"network byte order\"\nwhile '>' is \"big-endian\" — they are equivalent for standard sizes.\n",
      "time_seconds": 30
    },
    {
      "id": "q05",
      "lo_ref": "LO2",
      "bloom_level": "apply",
      "difficulty": "advanced",
      "type": "code_trace",
      "stem": "What is the output of this code?\n\n```python\nimport struct\ndata = struct.pack(\"<H\", 0x1234)\nprint(\" \".join(f\"{b:02x}\" for b in data))\n```\n",
      "options": {
        "a": "12 34",
        "b": "34 12",
        "c": "00 12 34",
        "d": "34 12 00 00"
      },
      "correct": "b",
      "explanation": "The format \"<H\" means little-endian unsigned short (2 bytes). In little-endian,\nthe LSB (0x34) comes first, so the output is \"34 12\". The value 0x1234 is\nstored as bytes [0x34, 0x12] in memory.\n",
      "time_seconds": 60
    },
    {
      "id": "q06",
      "lo_ref": "LO3",
      "bloom_level": "apply",
      "difficulty": "intermediate",
      "type": "multiple_choice",
      "stem": "A binary protocol header contains: magic (4B), type (1B), flags (1B),\nlength (4B), CRC (4B). What is struct.calcsize(\">4sBBII\")?\n",
      "options": {
        "a": "12 bytes",
        "b": "14 bytes",
        "c": "16 bytes",
        "d": "18 bytes"
      },
      "correct": "b",
      "explanation": "The format \">4sBBII\" breaks down as:\n- 4s = 4 bytes (magic)\n- B = 1 byte (type)\n- B = 1 byte (flags)\n- I = 4 bytes (length)\n- I = 4 bytes (CRC)\nTotal: 4 + 1 + 1 + 4 + 4 = 14 bytes\n",
      "time_seconds": 45
    },
    {
      "id": "q07",
      "lo_ref": "LO3",
      "bloom_level": "understand",
      "difficulty": "intermediate",
      "type": "multiple_choice",
      "stem": "Why do binary protocols typically include a \"magic number\" at the start\nof each message?\n",
      "options": {
        "a": "To encrypt the message header",
        "b": "To identify protocol type and enable resynchronisation",
        "c": "To compress the payload data",
        "d": "To calculate the checksum seed"
      },
      "correct": "b",
      "explanation": "Magic numbers serve two purposes: (1) identify the protocol type so\nreceivers can reject misrouted data and (2) enable resynchronisation\nafter corruption by scanning for the known byte sequence.\n",
      "time_seconds": 45
    },
    {
      "id": "q08",
      "lo_ref": "LO4",
      "bloom_level": "understand",
      "difficulty": "basic",
      "type": "multiple_choice",
      "stem": "How many TCP connections does FTP use to download a single file?\n",
      "options": {
        "a": "1 — commands and data share one connection",
        "b": "2 — one control channel, one data channel",
        "c": "3 — authentication, commands, and data",
        "d": "4 — one per FTP command issued"
      },
      "correct": "b",
      "explanation": "FTP uses exactly two TCP connections: a persistent control channel (port 21)\nfor commands and responses, and a temporary data channel (dynamic port) for\nfile transfers. This dual-channel architecture is unique to FTP.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-2",
      "time_seconds": 45
    },
    {
      "id": "q09",
      "lo_ref": "LO4",
      "bloom_level": "understand",
      "difficulty": "intermediate",
      "type": "multiple_choice",
      "stem": "In FTP passive mode (PASV), who initiates the data connection?\n",
      "options": {
        "a": "Server connects to client on port 20",
        "b": "Client connects to server on a dynamic port",
        "c": "Both sides open connections simultaneously",
        "d": "The firewall establishes the connection"
      },
      "correct": "b",
      "explanation": "In passive mode, the server responds with a port number (e.g., \"227 Entering\nPassive Mode (192,168,1,5,234,100)\") and the CLIENT initiates an outbound\nconnection to that port. This works through NAT because outbound connections\nare typically allowed.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-3",
      "time_seconds": 45
    },
    {
      "id": "q10",
      "lo_ref": "LO5",
      "bloom_level": "analyse",
      "difficulty": "advanced",
      "type": "multiple_choice",
      "stem": "A Wireshark capture shows: \"227 Entering Passive Mode (192,168,1,5,234,100)\".\nWhat port should the client connect to for data transfer?\n",
      "options": {
        "a": "234",
        "b": "100",
        "c": "60004",
        "d": "23410"
      },
      "correct": "c",
      "explanation": "The PASV response encodes the port as two numbers: p1 and p2.\nPort = (p1 × 256) + p2 = (234 × 256) + 100 = 59904 + 100 = 60004.\nThe IP address (192.168.1.5) is the server's address for the data connection.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-8",
      "time_seconds": 60
    },
    {
      "id": "q11",
      "lo_ref": "LO6",
      "bloom_level": "understand",
      "difficulty": "intermediate",
      "type": "multiple_choice",
      "stem": "A 100MB file transfer is interrupted at 35MB. With session-layer checkpointing,\nwhat happens when the connection is re-established?\n",
      "options": {
        "a": "Transfer restarts from 0MB",
        "b": "Transfer resumes from the last checkpoint (e.g., 30MB)",
        "c": "Transfer continues from exactly 35MB",
        "d": "Transfer fails permanently"
      },
      "correct": "b",
      "explanation": "Session-layer checkpointing saves progress at defined intervals (e.g., every\n10MB). On reconnection, the transfer resumes from the last confirmed checkpoint,\nnot from the exact interruption point. Some data may be re-transferred.\n",
      "time_seconds": 45
    },
    {
      "id": "q12",
      "lo_ref": "LO6",
      "bloom_level": "apply",
      "difficulty": "advanced",
      "type": "multiple_choice",
      "stem": "Which Session Layer concept allows a sender to ensure the receiver has\nsuccessfully processed data before continuing?\n",
      "options": {
        "a": "Flow control",
        "b": "Synchronisation points (checkpoints)",
        "c": "Error correction",
        "d": "Multiplexing"
      },
      "correct": "b",
      "explanation": "Synchronisation points (or checkpoints) are Session Layer mechanisms that\nmark confirmed progress. The sender waits for acknowledgement before\ncontinuing, enabling recovery without full retransmission. Flow control\nis Transport Layer; error correction is Data Link/Transport.\n",
      "time_seconds": 45
    },
    {
      "id": "q13",
      "lo_ref": "LO5",
      "bloom_level": "analyse",
      "difficulty": "advanced",
      "type": "multiple_choice",
      "points": 3,
      "stem": "In a Wireshark capture, you see:\n  Packet 1: TCP SYN to port 2121\n  Packet 2: TCP SYN-ACK from port 2121\n  Packet 3: TCP ACK\n  Packet 4: \"220 FTP Server Ready\"\n  Packet 5: \"USER test\"\n\nAt which packet does the SESSION layer become active?\n",
      "options": {
        "a": "Packet 1 — when TCP connection initiates",
        "b": "Packet 3 — when TCP handshake completes",
        "c": "Packet 4 — when FTP server sends banner",
        "d": "Packet 5 — when authentication begins"
      },
      "correct": "d",
      "explanation": "TCP handshake (packets 1-3) establishes the transport connection.\nThe server banner (packet 4) is still transport-level data.\nSession layer activity begins with USER command (packet 5) which\ninitiates the authentication dialogue — a session-layer concern.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-1",
      "time_seconds": 90
    },
    {
      "id": "q14",
      "lo_ref": "LO6",
      "bloom_level": "create",
      "difficulty": "advanced",
      "type": "open_response",
      "points": 5,
      "stem": "Design a checkpoint format for resumable file transfers. Your format\nmust include: session ID, file path, bytes transferred, timestamp\nand integrity verification. Describe the binary layout.\n",
      "rubric": [
        "Session ID present (1 point)",
        "File path with length prefix (1 point)",
        "Byte offset as 64-bit integer (1 point)",
        "Timestamp in Unix epoch (1 point)",
        "CRC or hash for verification (1 point)"
      ],
      "sample_answer": "Format: \">4s I H {path_len}s Q Q I\"\n- Magic: 4 bytes \"CKPT\"\n- Session ID: 4 bytes (unsigned int)\n- Path length: 2 bytes (unsigned short)\n- File path: variable (UTF-8 encoded)\n- Bytes transferred: 8 bytes (unsigned long long)\n- Timestamp: 8 bytes (Unix epoch)\n- CRC-32: 4 bytes\n",
      "max_points": 5,
      "time_seconds": 180
    },
    {
      "id": "q15",
      "lo_ref": "LO6",
      "bloom_level": "evaluate",
      "difficulty": "advanced",
      "type": "multiple_choice",
      "points": 3,
      "stem": "A file transfer uses 1MB checkpoints. The transfer fails at 47.3MB.\nWhich recovery approach minimises retransmission whilst ensuring integrity?\n",
      "options": {
        "a": "Restart from 0MB — ensures complete data integrity",
        "b": "Resume from 47MB checkpoint — latest complete checkpoint",
        "c": "Resume from 46MB — adds safety margin for partial writes",
        "d": "Resume from 47.3MB — continue exactly where stopped"
      },
      "correct": "b",
      "explanation": "Option (b) resumes from the last verified checkpoint (47MB).\nOption (d) is risky because 47.3MB was never confirmed received.\nOption (c) wastes bandwidth unnecessarily.\nOption (a) defeats the purpose of checkpointing entirely.\n",
      "misconception_ref": "docs/misconceptions.md#misconception-4",
      "time_seconds": 60
    }
  ],
  "note": "Generated by formative/run_quiz.py --export json"
}
