# ═══════════════════════════════════════════════════════════════════════════════
# Formative Assessment Quiz — Week 8: Transport Layer & HTTP
# Computer Networks — ASE, CSIE | by ing. dr. Antonio Clim
# ═══════════════════════════════════════════════════════════════════════════════
#
# This quiz was designed through extensive brainstorming sessions with Andrei T.
# and refined using pedagogical principles from the Psychopedagogy module
# (Universitatea Politehnica București — where engineers learn to teach).
#
# "The best way to learn is to test yourself before you think you're ready."
# — A lesson from preparing teaching materials at 2 AM
#
# Usage:
#   python formative/run_quiz.py                    # Run all questions
#   python formative/run_quiz.py --random           # Randomise order
#   python formative/run_quiz.py --lo LO3           # Filter by Learning Objective
#   python formative/run_quiz.py --difficulty basic # Filter by difficulty
#
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  week: 8
  topic: "Transport Layer — HTTP Server Implementation and Reverse Proxies"
  version: "1.0.0"
  author: "ing. dr. Antonio Clim"
  contributors:
    - name: "Andrei T."
      role: "Brainstorming and pedagogical review"
  institution: "ASE București — CSIE"
  estimated_time_minutes: 15
  passing_score: 70
  total_questions: 15
  
  learning_objectives:
    LO1: "Identify TCP/UDP headers and explain port demultiplexing"
    LO2: "Describe the three-way handshake mechanism"
    LO3: "Implement a functional HTTP/1.1 server"
    LO4: "Construct a reverse proxy with round-robin load balancing"
    LO5: "Analyse packet captures to identify TCP flags and connection states"
    LO6: "Evaluate security vulnerabilities and implement mitigations"

  bloom_levels:
    remember: "Recall facts and basic concepts"
    understand: "Explain ideas or concepts"
    apply: "Use information in new situations"
    analyse: "Draw connections among ideas"
    evaluate: "Justify a decision or course of action"

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS
# ═══════════════════════════════════════════════════════════════════════════════

questions:

  # ─────────────────────────────────────────────────────────────────────────────
  # LO1: TCP/UDP Headers and Port Demultiplexing
  # ─────────────────────────────────────────────────────────────────────────────
  
  - id: q01
    lo_ref: LO1
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: |
      What is the size of the port number field in TCP and UDP headers?
    options:
      a: "8 bits (256 possible ports)"
      b: "16 bits (65,536 possible ports)"
      c: "32 bits (4 billion possible ports)"
      d: "Variable length depending on protocol version"
    correct: b
    explanation: |
      Port numbers are 16-bit unsigned integers (0-65535) in both TCP and UDP.
      This is why the maximum port number is 65535, not 65536 (we start from 0).
      Andrei T. once asked: "Why not 32-bit?" — Because 65K ports per host is plenty,
      and smaller headers mean less overhead.
    misconception_ref: "docs/misconceptions.md#port-size"
    points: 5

  - id: q02
    lo_ref: LO1
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      A host receives a UDP datagram with destination port 53.
      How does the operating system know which process should receive it?
    options:
      a: "It checks the process ID embedded in the UDP header"
      b: "It looks up which socket is bound to port 53"
      c: "It broadcasts to all running processes"
      d: "It uses the source IP address to identify the process"
    correct: b
    explanation: |
      The OS maintains a table mapping port numbers to sockets.
      When a datagram arrives, the OS demultiplexes by looking up the destination port.
      This is why you get "Address already in use" when two processes try to bind the same port.
    misconception_ref: "docs/misconceptions.md#demultiplexing"
    points: 5

  - id: q03
    lo_ref: LO1
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: |
      Complete the socket creation for a TCP server:
      server = socket.socket(socket.AF_INET, socket._______)
    correct:
      - "SOCK_STREAM"
      - "socket.SOCK_STREAM"
    explanation: |
      SOCK_STREAM = TCP (reliable, ordered, connection-oriented)
      SOCK_DGRAM = UDP (unreliable, unordered, connectionless)
      A common mistake from the psychopedagogy module: students remember "stream" 
      sounds like water flowing continuously — which is exactly how TCP works!
    points: 5

  # ─────────────────────────────────────────────────────────────────────────────
  # LO2: Three-Way Handshake
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q04
    lo_ref: LO2
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: |
      What is the correct sequence of TCP flags during connection establishment?
    options:
      a: "ACK → SYN → SYN-ACK"
      b: "SYN → ACK → SYN-ACK"
      c: "SYN → SYN-ACK → ACK"
      d: "SYN-ACK → SYN → ACK"
    correct: c
    explanation: |
      The three-way handshake: Client sends SYN, Server responds with SYN-ACK,
      Client confirms with ACK. Mnemonic from Andrei: "SYN-cerely, SYN-cerely ACKnowledged, ACK!"
    misconception_ref: "docs/misconceptions.md#third-ack-optional"
    points: 5

  - id: q05
    lo_ref: LO2
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      Why does TCP require THREE packets for connection establishment instead of two?
    options:
      a: "To reduce network congestion by spreading packets over time"
      b: "To synchronise sequence numbers in BOTH directions"
      c: "To allow time for DNS resolution between packets"
      d: "To comply with RFC requirements for backward compatibility"
    correct: b
    explanation: |
      Two packets would only confirm one direction. The third ACK proves:
      - Client can send (SYN arrived)
      - Server can send AND receive (SYN-ACK arrived)  
      - Client can receive (ACK confirms SYN-ACK was received)
      Without the third packet, the server cannot confirm the client received its response.
    misconception_ref: "docs/misconceptions.md#third-ack-optional"
    points: 10

  - id: q06
    lo_ref: LO2
    bloom_level: analyse
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      You capture these packets in Wireshark:
      
        Packet 1: 192.168.1.10 → 10.0.0.5  [SYN] Seq=1000
        Packet 2: 10.0.0.5 → 192.168.1.10  [RST, ACK] Seq=0, Ack=1001
      
      What does this indicate?
    options:
      a: "Successful connection establishment"
      b: "The server's port is closed or no service is listening"
      c: "Network congestion caused packet loss"
      d: "The client cancelled the connection"
    correct: b
    explanation: |
      RST (Reset) immediately after SYN means "I received your connection request,
      but nothing is listening on that port." The server's TCP stack responds
      automatically — no application involvement needed.
      Wireshark filter to find these: tcp.flags.reset == 1
    points: 10

  # ─────────────────────────────────────────────────────────────────────────────
  # LO3: HTTP Server Implementation
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q07
    lo_ref: LO3
    bloom_level: remember
    difficulty: basic
    question_type: fill_blank
    stem: |
      HTTP headers are separated from the body by a blank line.
      In bytes, this separator is: _______
    correct:
      - "\\r\\n\\r\\n"
      - "\r\n\r\n"
      - "CRLF CRLF"
      - "b'\\r\\n\\r\\n'"
    explanation: |
      HTTP uses CRLF (Carriage Return + Line Feed) as line endings.
      Two consecutive CRLFs = blank line = end of headers.
      Fun fact from 2 AM debugging: forgetting this separator makes browsers hang forever.
    points: 5

  - id: q08
    lo_ref: LO3
    bloom_level: apply
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      Your HTTP server receives a HEAD request for /index.html (file size: 1024 bytes).
      What should the response include?
    options:
      a: "Status line, headers, and the 1024-byte file content"
      b: "Status line and headers only, with Content-Length: 1024"
      c: "Status line only, no headers or body"
      d: "Status line, headers, and Content-Length: 0"
    correct: b
    explanation: |
      HEAD returns the SAME headers that GET would return, but with NO body.
      Content-Length must still show what GET would return (1024).
      This is used for cache validation — check if a file changed without downloading it.
    misconception_ref: "docs/misconceptions.md#head-returns-head-metadata"
    points: 10

  - id: q09
    lo_ref: LO3
    bloom_level: apply
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      What HTTP status code should your server return for a request to /../../../etc/passwd 
      when path traversal is detected and blocked?
    options:
      a: "400 Bad Request — the URL is malformed"
      b: "403 Forbidden — access denied due to security policy"
      c: "404 Not Found — file doesn't exist in web root"
      d: "500 Internal Server Error — security check failed"
    correct: b
    explanation: |
      403 Forbidden is semantically correct: "I understood your request, but I refuse."
      - 400 = malformed syntax (but /../ is syntactically valid)
      - 404 = resource doesn't exist (it might, we just won't serve it)
      - 500 = server error (security working correctly isn't an error)
    misconception_ref: "docs/misconceptions.md#403-vs-404"
    points: 10

  # ─────────────────────────────────────────────────────────────────────────────
  # LO4: Reverse Proxy and Load Balancing
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q10
    lo_ref: LO4
    bloom_level: understand
    difficulty: basic
    question_type: multiple_choice
    stem: |
      In a reverse proxy architecture, what does the client browser connect to?
    options:
      a: "Directly to all backend servers simultaneously"
      b: "Only to the reverse proxy (backends are hidden)"
      c: "To a random backend selected by DNS"
      d: "To the backend with the lowest load"
    correct: b
    explanation: |
      The "reverse" in reverse proxy means it's deployed by the SERVER side.
      Clients see only the proxy — backends are completely hidden.
      This is opposite to a forward proxy (deployed by client, hides client from server).
    misconception_ref: "docs/misconceptions.md#reverse-vs-forward-proxy"
    points: 5

  - id: q11
    lo_ref: LO4
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: |
      In round-robin with 3 backends, to cycle the index correctly after each request:
      self.index = (self.index + 1) % _______
    correct:
      - "len(self.backends)"
      - "3"
      - "len(backends)"
    explanation: |
      The modulo operation makes the index wrap around: 0→1→2→0→1→2→...
      Without %, you'd get IndexError when index exceeds list length.
      Andrei's debugging tip: "If round-robin isn't cycling, check your modulo!"
    points: 5

  - id: q12
    lo_ref: LO4
    bloom_level: analyse
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      nginx is configured with weighted round-robin (weights 5:3:1 for backends A:B:C).
      After exactly 9 requests, the distribution should be:
    options:
      a: "A:3, B:3, C:3 — weights are only hints"
      b: "A:5, B:3, C:1 — exact proportional distribution"
      c: "A:9, B:0, C:0 — highest weight gets all traffic"
      d: "Cannot determine without knowing request timing"
    correct: b
    explanation: |
      Weighted round-robin distributes REQUESTS proportionally, not randomly.
      Total weight = 9, so in 9 requests: A gets 5, B gets 3, C gets 1.
      nginx's smooth weighted round-robin ensures this even for small request counts.
    misconception_ref: "docs/misconceptions.md#round-robin-equal-load"
    points: 10

  # ─────────────────────────────────────────────────────────────────────────────
  # LO5: Packet Analysis
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q13
    lo_ref: LO5
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: |
      Write the Wireshark display filter to show only TCP SYN packets (no SYN-ACK):
      tcp.flags.syn == 1 && tcp.flags._______ == 0
    correct:
      - "ack"
      - "ACK"
    explanation: |
      SYN packets have SYN=1, ACK=0. SYN-ACK packets have SYN=1, ACK=1.
      This filter is essential for counting new connection attempts.
      Pro tip: save this as a filter button in Wireshark.
    points: 5

  - id: q14
    lo_ref: LO5
    bloom_level: analyse
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      You see multiple HTTP request/response pairs in Wireshark, all with tcp.stream == 0.
      What does this indicate?
    options:
      a: "Each request used a different TCP connection"
      b: "All requests reused the same TCP connection (keep-alive)"
      c: "The packets were captured out of order"
      d: "Wireshark failed to reassemble the TCP stream"
    correct: b
    explanation: |
      tcp.stream is Wireshark's identifier for a TCP connection.
      Same stream number = same connection = HTTP keep-alive is working.
      Multiple streams would indicate connection-per-request (HTTP/1.0 style).
    misconception_ref: "docs/misconceptions.md#http-one-request-per-connection"
    points: 10

  # ─────────────────────────────────────────────────────────────────────────────
  # LO6: Security Evaluation
  # ─────────────────────────────────────────────────────────────────────────────

  - id: q15
    lo_ref: LO6
    bloom_level: evaluate
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      Your HTTP server uses this path validation:
      
        if '..' in requested_path:
            return 403
      
      Is this implementation secure?
    options:
      a: "Yes — it blocks all directory traversal attempts"
      b: "No — encoded variants like %2e%2e can bypass it"
      c: "Yes — HTTP standards require decoded paths"
      d: "No — but only on Windows systems"
    correct: b
    explanation: |
      Simple string matching is insufficient! Attackers can use:
      - URL encoding: %2e%2e = ..
      - Double encoding: %252e%252e
      - Unicode: various representations
      
      Correct approach: URL-decode, then os.path.normpath(), then verify containment.
      This is why we teach is_safe_path() with proper normalisation.
    misconception_ref: "docs/misconceptions.md#simple-string-security"
    points: 15

# ═══════════════════════════════════════════════════════════════════════════════
# SCORING
# ═══════════════════════════════════════════════════════════════════════════════

scoring:
  total_points: 115
  passing_threshold: 80  # ~70%
  
  grade_boundaries:
    excellent: 100    # 87%+
    good: 85          # 74%+
    satisfactory: 70  # 61%+
    needs_improvement: 0
  
  feedback_messages:
    excellent: |
      Excellent work! You have a solid understanding of transport layer concepts
      and HTTP implementation. Ready to tackle the homework assignments.
    good: |
      Good progress! Review the misconceptions document for topics where you
      hesitated. Consider re-doing the Parsons problems for hands-on practice.
    satisfactory: |
      You're on the right track but need more practice. Focus on:
      - Re-reading docs/theory_summary.md
      - Tracing through docs/code_tracing.md exercises
      - Discussing with peers using docs/peer_instruction.md
    needs_improvement: |
      Don't worry — this material takes time to absorb. Recommended approach:
      1. Review the lecture slides (00LECTURES/S8Theory_Week8_EN.html)
      2. Work through concept_analogies.md for intuitive understanding
      3. Complete the exercises with a partner (see pair_programming_guide.md)
      4. Retake this quiz after 24 hours of practice

# ═══════════════════════════════════════════════════════════════════════════════
# ACKNOWLEDGMENTS
# ═══════════════════════════════════════════════════════════════════════════════
#
# This quiz structure was developed with input from:
# - Andrei T. (ASE colleague) — question design and misconception identification
# - Principles from DPPD module, Universitatea Politehnica București — 
#   where I learned that good assessment is about revealing understanding,
#   not catching students out. (ASE doesn't accept engineers for their 
#   psychopedagogy programme — but I understand their reasoning.)
#
# The questions target common misconceptions identified during 3+ years of
# teaching Computer Networks at ASE-CSIE.
#
# "A good question makes the student think. A great question makes them
# realise they need to think differently." — from a DPPD lecture that
# stuck with me
#
# ═══════════════════════════════════════════════════════════════════════════════
