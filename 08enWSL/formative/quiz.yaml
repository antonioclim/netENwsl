# ═══════════════════════════════════════════════════════════════════════════════
# Formative Assessment Quiz — Week 8: Transport Layer & HTTP
# Computer Networks — ASE, CSIE
# ═══════════════════════════════════════════════════════════════════════════════
#
# This quiz supports:
# - Interactive CLI mode: python formative/run_quiz.py
# - LMS export (Moodle/Canvas): python formative/run_quiz.py --export-lms
#
# Usage:
#   python formative/run_quiz.py                    # Run all questions
#   python formative/run_quiz.py --random           # Randomise order
#   python formative/run_quiz.py --lo LO3           # Filter by Learning Objective
#   python formative/run_quiz.py --difficulty basic # Filter by difficulty
#   python formative/run_quiz.py --export-lms       # Export for Moodle/Canvas
#
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  week: 8
  topic: "Transport Layer — HTTP Server Implementation and Reverse Proxies"
  version: "2.0.0"
  institution: "ASE București — CSIE"
  estimated_time_minutes: 20
  passing_score: 70
  total_questions: 20
  
  # LMS export settings
  lms_export:
    format: "QTI"  # Question and Test Interoperability standard
    category: "Week8_Transport_HTTP"
    shuffle_answers: true
    points_per_question: 5
  
  learning_objectives:
    LO1: "Identify TCP/UDP headers and explain port demultiplexing"
    LO2: "Describe the three-way handshake mechanism"
    LO3: "Implement a functional HTTP/1.1 server"
    LO4: "Construct a reverse proxy with round-robin load balancing"
    LO5: "Analyse packet captures to identify TCP flags and connection states"
    LO6: "Evaluate security vulnerabilities and implement mitigations"

  bloom_levels:
    remember: "Recall facts and basic concepts"
    understand: "Explain ideas or concepts"
    apply: "Use information in new situations"
    analyse: "Draw connections among ideas"
    evaluate: "Justify a decision or course of action"

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO1: TCP/UDP Headers and Port Demultiplexing
# ═══════════════════════════════════════════════════════════════════════════════

questions:

  - id: q01
    lo_ref: LO1
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: "What is the size of the port number field in TCP and UDP headers?"
    options:
      a: "8 bits (256 possible ports)"
      b: "16 bits (65,536 possible ports)"
      c: "32 bits (4 billion possible ports)"
      d: "Variable length depending on protocol version"
    correct: b
    explanation: |
      Port numbers are 16-bit unsigned integers (0-65535) in both TCP and UDP.
      This is why the maximum port number is 65535 not 65536 (we start from 0).
    misconception_ref: "docs/misconceptions.md#port-size"
    points: 5

  - id: q02
    lo_ref: LO1
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      A host receives a UDP datagram with destination port 53.
      How does the operating system know which process should receive it?
    options:
      a: "It checks the process ID embedded in the UDP header"
      b: "It looks up which socket is bound to port 53"
      c: "It broadcasts to all running processes"
      d: "It uses the source IP address to identify the process"
    correct: b
    explanation: |
      The OS maintains a table mapping port numbers to sockets.
      When a datagram arrives the OS demultiplexes by looking up the destination port.
      This is why you get "Address already in use" when two processes try to bind the same port.
    misconception_ref: "docs/misconceptions.md#demultiplexing"
    points: 5

  - id: q03
    lo_ref: LO1
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: "Complete the socket creation for a TCP server: server = socket.socket(socket.AF_INET, socket._______)"
    correct:
      - "SOCK_STREAM"
      - "socket.SOCK_STREAM"
    explanation: |
      SOCK_STREAM = TCP (reliable, ordered, connection-oriented)
      SOCK_DGRAM = UDP (unreliable, unordered, connectionless)
    points: 5

  - id: q04
    lo_ref: LO1
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: "Which port range is designated for well-known services?"
    options:
      a: "0-255"
      b: "0-1023"
      c: "1024-49151"
      d: "49152-65535"
    correct: b
    explanation: |
      Ports 0-1023 are well-known ports (HTTP=80, HTTPS=443, SSH=22, DNS=53).
      Ports 1024-49151 are registered ports.
      Ports 49152-65535 are dynamic/ephemeral ports.
    points: 5

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO2: Three-Way Handshake
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q05
    lo_ref: LO2
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: "What is the correct sequence of TCP flags during connection establishment?"
    options:
      a: "ACK → SYN → SYN-ACK"
      b: "SYN → ACK → SYN-ACK"
      c: "SYN → SYN-ACK → ACK"
      d: "SYN-ACK → SYN → ACK"
    correct: c
    explanation: |
      The three-way handshake: Client sends SYN, Server responds with SYN-ACK,
      Client confirms with ACK.
    misconception_ref: "docs/misconceptions.md#third-ack-optional"
    points: 5

  - id: q06
    lo_ref: LO2
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: "Why does TCP require THREE packets for connection establishment instead of two?"
    options:
      a: "To reduce network congestion by spreading packets over time"
      b: "Both sides must confirm they can send AND receive (bidirectional verification)"
      c: "The third packet carries the first data payload"
      d: "Four packets would be needed for full reliability but TCP sacrifices reliability for speed"
    correct: b
    explanation: |
      Three packets ensure bidirectional confirmation:
      1. SYN: Client proves it can send
      2. SYN-ACK: Server proves it can send AND receive
      3. ACK: Client proves it can receive
      Two packets would only confirm one direction.
    points: 5

  - id: q07
    lo_ref: LO2
    bloom_level: analyse
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      You capture this handshake:
      Packet 1: SYN, Seq=1000
      Packet 2: SYN-ACK, Seq=5000, Ack=1001
      Packet 3: ACK, Seq=1001, Ack=?
      What is the Ack value in Packet 3?
    options:
      a: "5000"
      b: "5001"
      c: "1001"
      d: "1002"
    correct: b
    explanation: |
      The ACK number is always the next expected sequence number.
      Server sent SYN with Seq=5000, so client acknowledges 5001 (5000 + 1).
    points: 5

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO3: HTTP/1.1 Server Implementation
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q08
    lo_ref: LO3
    bloom_level: remember
    difficulty: basic
    question_type: multiple_choice
    stem: "What character sequence separates HTTP header lines?"
    options:
      a: "\\n (LF only)"
      b: "\\r\\n (CRLF)"
      c: "\\r (CR only)"
      d: "Two spaces"
    correct: b
    explanation: |
      HTTP uses CRLF (Carriage Return + Line Feed, \\r\\n) as line terminators.
      The end of headers is marked by a blank line (\\r\\n\\r\\n).
    points: 5

  - id: q09
    lo_ref: LO3
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: "What does the HTTP HEAD method return?"
    options:
      a: "Only the first 1KB of the response body"
      b: "The headers that would be returned for a GET request (no body)"
      c: "Metadata about the HEAD request itself"
      d: "The server's capabilities and supported methods"
    correct: b
    explanation: |
      HEAD returns the same headers as GET but without the response body.
      Useful for checking if a resource exists or getting its size without downloading it.
    misconception_ref: "docs/misconceptions.md#head-returns-head-metadata"
    points: 5

  - id: q10
    lo_ref: LO3
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: "To decode HTTP header bytes use encoding: raw_data.decode('_______')"
    correct:
      - "iso-8859-1"
      - "latin-1"
      - "latin1"
    explanation: |
      HTTP/1.1 headers use ISO-8859-1 (Latin-1) encoding per RFC 7230.
      UTF-8 is only used for the message body when specified by Content-Type.
    points: 5

  - id: q11
    lo_ref: LO3
    bloom_level: apply
    difficulty: intermediate
    question_type: multiple_choice
    stem: "Which HTTP status code should be returned for a malformed request?"
    options:
      a: "404 Not Found"
      b: "400 Bad Request"
      c: "500 Internal Server Error"
      d: "403 Forbidden"
    correct: b
    explanation: |
      400 Bad Request indicates the server cannot process the request due to client error
      (malformed syntax, invalid framing, deceptive routing).
    points: 5

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO4: Reverse Proxy with Load Balancing
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q12
    lo_ref: LO4
    bloom_level: understand
    difficulty: basic
    question_type: multiple_choice
    stem: "What is the primary difference between a forward proxy and a reverse proxy?"
    options:
      a: "Forward proxies are faster than reverse proxies"
      b: "Forward proxies serve clients; reverse proxies serve backend servers"
      c: "Forward proxies use HTTP; reverse proxies use HTTPS"
      d: "There is no difference; the terms are interchangeable"
    correct: b
    explanation: |
      Forward proxy: Client knows it is using a proxy; proxy hides client from server.
      Reverse proxy: Client thinks it is talking to origin; proxy hides servers from client.
    misconception_ref: "docs/misconceptions.md#reverse-vs-forward-proxy"
    points: 5

  - id: q13
    lo_ref: LO4
    bloom_level: apply
    difficulty: intermediate
    question_type: multiple_choice
    stem: |
      A load balancer uses weights: backend1=5, backend2=3, backend3=2.
      After 10 requests how many should backend1 have received?
    options:
      a: "3"
      b: "4"
      c: "5"
      d: "10"
    correct: c
    explanation: |
      Total weight = 5 + 3 + 2 = 10
      backend1 receives: 10 × (5/10) = 5 requests
    points: 5

  - id: q14
    lo_ref: LO4
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: "Why might equal round-robin NOT distribute load equally across backends?"
    options:
      a: "Round-robin algorithms are inherently random"
      b: "Request processing times vary; some requests take longer than others"
      c: "Network latency affects the order of requests"
      d: "Round-robin only works with exactly 3 backends"
    correct: b
    explanation: |
      Equal request distribution ≠ equal load.
      If one backend receives long-running requests it may be overloaded
      even with equal request counts.
    misconception_ref: "docs/misconceptions.md#round-robin-equal-load"
    points: 5

  - id: q15
    lo_ref: LO4
    bloom_level: apply
    difficulty: intermediate
    question_type: fill_blank
    stem: "The HTTP header that passes the original client IP through a proxy is: _______"
    correct:
      - "X-Forwarded-For"
      - "x-forwarded-for"
    explanation: |
      X-Forwarded-For (XFF) is the de-facto standard header for identifying
      the originating IP address of a client connecting through a proxy.
    points: 5

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO5: Packet Capture Analysis
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q16
    lo_ref: LO5
    bloom_level: apply
    difficulty: intermediate
    question_type: multiple_choice
    stem: "Which Wireshark filter shows only TCP SYN packets (not SYN-ACK)?"
    options:
      a: "tcp.flags.syn == 1"
      b: "tcp.flags.syn == 1 && tcp.flags.ack == 0"
      c: "tcp.syn"
      d: "tcp contains SYN"
    correct: b
    explanation: |
      SYN packets have SYN=1 and ACK=0.
      SYN-ACK packets have both SYN=1 and ACK=1.
      The filter must exclude ACK to show only pure SYN packets.
    points: 5

  - id: q17
    lo_ref: LO5
    bloom_level: analyse
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      You see [RST, ACK] immediately after [SYN]. What happened?
    options:
      a: "Connection established successfully"
      b: "Connection refused — no service listening on that port"
      c: "Connection timed out"
      d: "Firewall blocked the connection silently"
    correct: b
    explanation: |
      RST (Reset) immediately after SYN indicates connection refused.
      The server actively rejected the connection (port closed or not listening).
      Firewall drops would show no response (timeout) not RST.
    points: 5

  - id: q18
    lo_ref: LO5
    bloom_level: understand
    difficulty: intermediate
    question_type: multiple_choice
    stem: "In HTTP/1.1 multiple requests can use the same TCP connection because of:"
    options:
      a: "HTTP/1.1 multiplexing"
      b: "Persistent connections (keep-alive)"
      c: "TCP pipelining"
      d: "Connection pooling at OS level"
    correct: b
    explanation: |
      HTTP/1.1 uses persistent connections by default (Connection: keep-alive).
      Multiple request-response pairs share one TCP connection.
      True multiplexing (concurrent streams) is an HTTP/2 feature.
    misconception_ref: "docs/misconceptions.md#http-one-request-per-connection"
    points: 5

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS — LO6: Security Vulnerabilities
# ═══════════════════════════════════════════════════════════════════════════════

  - id: q19
    lo_ref: LO6
    bloom_level: evaluate
    difficulty: advanced
    question_type: multiple_choice
    stem: |
      A client requests: GET /../../../etc/passwd HTTP/1.1
      What should your server return?
    options:
      a: "200 OK with the file contents"
      b: "400 Bad Request"
      c: "403 Forbidden or 404 Not Found"
      d: "500 Internal Server Error"
    correct: c
    explanation: |
      This is a directory traversal attack. The server should:
      1. Detect the path escapes the document root
      2. Return 403 (reveals the file exists) or 404 (reveals nothing)
      Never return the file contents!
    misconception_ref: "docs/misconceptions.md#403-vs-404"
    points: 5

  - id: q20
    lo_ref: LO6
    bloom_level: evaluate
    difficulty: advanced
    question_type: multiple_choice
    stem: "Which security issue does rate limiting primarily address?"
    options:
      a: "SQL injection"
      b: "Cross-site scripting (XSS)"
      c: "Denial of service (DoS) and brute force attacks"
      d: "Man-in-the-middle attacks"
    correct: c
    explanation: |
      Rate limiting restricts how many requests a client can make in a time window.
      This protects against DoS attacks (overwhelming the server) and
      brute force attacks (password guessing, credential stuffing).
    points: 5
