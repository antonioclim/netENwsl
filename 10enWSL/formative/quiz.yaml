# Week 10 Formative Assessment Quiz
# Computer Networks — ASE, CSIE | by ing. dr. Antonio Clim
#
# Run with: python formative/run_quiz.py
# Options:  --random (shuffle questions)
#           --limit N (first N questions only)
#           --lo LO1 (filter by Learning Objective)

metadata:
  week: 10
  topic: "Application Layer Protocols: HTTP/HTTPS, REST, DNS, SSH, FTP"
  version: "1.0.0"
  estimated_time: "12-15 minutes"
  passing_score: 70
  total_questions: 10
  bloom_distribution:
    remember: 2
    understand: 3
    apply: 3
    analyse: 2
  lo_coverage:
    - LO1  # TLS certificates in HTTPS
    - LO2  # REST API Richardson levels
    - LO3  # DNS query/response structure
    - LO4  # Implement protocol clients
    - LO5  # Security: encrypted vs unencrypted

questions:
  # ═══════════════════════════════════════════════════════════════════════════
  # LO1: TLS Certificates (Remember + Understand)
  # ═══════════════════════════════════════════════════════════════════════════
  - id: q01
    lo_ref: LO1
    bloom_level: remember
    difficulty: basic
    stem: "What information is visible to a network observer during an HTTPS connection?"
    options:
      a: "The full URL path and query parameters"
      b: "The domain name via SNI (Server Name Indication)"
      c: "Nothing at all — everything is encrypted"
      d: "HTTP headers but not the body"
    correct: b
    explanation: |
      The domain name is visible through SNI in the TLS handshake. The URL path,
      query parameters, headers and body are all encrypted. The destination IP
      address is also visible.
    misconception_ref: "docs/misconceptions.md#misconception-1"
    verify_command: "# Capture TLS handshake: filter ssl.handshake.extensions_server_name"

  - id: q02
    lo_ref: LO1
    bloom_level: understand
    difficulty: intermediate
    stem: "Why does TLS use symmetric encryption for bulk data transfer instead of asymmetric encryption throughout?"
    options:
      a: "Symmetric encryption is more secure than asymmetric"
      b: "Asymmetric encryption cannot handle large data"
      c: "Symmetric encryption is significantly faster (~1000x)"
      d: "Browsers only support symmetric encryption"
    correct: c
    explanation: |
      Asymmetric cryptography (RSA, ECDSA) is computationally expensive — about
      1000x slower than symmetric algorithms (AES, ChaCha20). TLS uses asymmetric
      crypto only during the handshake to authenticate and establish a shared
      symmetric key, then switches to fast symmetric encryption for data.
    misconception_ref: "docs/misconceptions.md#misconception-1"

  # ═══════════════════════════════════════════════════════════════════════════
  # LO2: REST Richardson Maturity Model (Understand + Apply)
  # ═══════════════════════════════════════════════════════════════════════════
  - id: q03
    lo_ref: LO2
    bloom_level: understand
    difficulty: intermediate
    stem: |
      Consider this API endpoint: POST /api/users/123/update
      According to the Richardson Maturity Model, what level does this represent?
    options:
      a: "Level 0 — RPC-style single endpoint"
      b: "Level 1 — Resources with URIs but action-style"
      c: "Level 2 — Proper HTTP verbs and status codes"
      d: "Level 3 — Full HATEOAS compliance"
    correct: b
    explanation: |
      This endpoint has resource-oriented URIs (/api/users/123) but uses
      action-style subpaths (/update) instead of HTTP verbs. A Level 2 API
      would use PUT /api/users/123 instead of POST /api/users/123/update.
    misconception_ref: "docs/misconceptions.md#misconception-5"

  - id: q04
    lo_ref: LO2
    bloom_level: apply
    difficulty: intermediate
    stem: "Which HTTP status code should a REST Level 2 API return after successfully creating a new resource?"
    options:
      a: "200 OK"
      b: "201 Created"
      c: "204 No Content"
      d: "302 Found"
    correct: b
    explanation: |
      201 Created is the correct status for successful resource creation.
      200 OK is for successful GET/PUT. 204 No Content is for successful
      DELETE. Level 2 requires semantic use of HTTP status codes.
    verify_command: "curl -X POST http://localhost:5000/level2/users -d '{\"name\":\"test\"}' -w '%{http_code}'"

  - id: q05
    lo_ref: LO2
    bloom_level: apply
    difficulty: advanced
    stem: "What distinguishes a Level 3 (HATEOAS) REST API from Level 2?"
    options:
      a: "Level 3 uses JSON instead of XML"
      b: "Level 3 responses include hypermedia links to related resources"
      c: "Level 3 requires authentication on all endpoints"
      d: "Level 3 uses WebSockets instead of HTTP"
    correct: b
    explanation: |
      HATEOAS (Hypermedia As The Engine Of Application State) means responses
      include links like {"_links": {"self": "/users/1", "orders": "/users/1/orders"}}.
      This allows clients to discover available actions without hardcoding URLs.
    verify_command: "curl http://localhost:5000/level3/users | jq '._links'"

  # ═══════════════════════════════════════════════════════════════════════════
  # LO3: DNS Query Structure (Remember + Analyse)
  # ═══════════════════════════════════════════════════════════════════════════
  - id: q06
    lo_ref: LO3
    bloom_level: remember
    difficulty: basic
    stem: "What transport protocol(s) does DNS use?"
    options:
      a: "UDP only, always on port 53"
      b: "TCP only, always on port 53"
      c: "Both UDP and TCP on port 53, depending on response size"
      d: "UDP on port 53 for queries, TCP on port 80 for responses"
    correct: c
    explanation: |
      DNS uses UDP for most queries (efficiency), but switches to TCP when
      responses exceed 512 bytes (traditional) or ~1232 bytes (EDNS). Zone
      transfers (AXFR/IXFR) always use TCP. The TC (truncation) bit signals
      the client to retry over TCP.
    misconception_ref: "docs/misconceptions.md#misconception-7"
    verify_command: "dig @8.8.8.8 google.com +tcp  # Force TCP"

  - id: q07
    lo_ref: LO3
    bloom_level: analyse
    difficulty: advanced
    stem: |
      A DNS response has the TC (truncation) bit set. What should the client do?
    options:
      a: "Accept the partial response as complete"
      b: "Retry the query using TCP instead of UDP"
      c: "Query a different DNS server"
      d: "Increase the UDP buffer size and retry"
    correct: b
    explanation: |
      The TC bit indicates the response was truncated because it exceeded
      the UDP packet size limit. The standard behaviour is to retry the
      same query over TCP, which has no size limit.
    verify_command: "dig @127.0.0.1 -p 5353 large-record.lab.local  # Observe TC bit"

  # ═══════════════════════════════════════════════════════════════════════════
  # LO4: Protocol Implementation (Apply)
  # ═══════════════════════════════════════════════════════════════════════════
  - id: q08
    lo_ref: LO4
    bloom_level: apply
    difficulty: intermediate
    stem: "How many TCP connections does FTP establish to download a single file?"
    options:
      a: "One connection for everything"
      b: "Two connections — control (port 21) and data (high port)"
      c: "Three connections — authentication, command and data"
      d: "One connection that changes ports during transfer"
    correct: b
    explanation: |
      FTP uses a dual-channel architecture: a persistent control connection
      on port 21 for commands/responses, and a separate data connection for
      actual file transfers. In passive mode, the server opens a high port
      and the client connects to it.
    misconception_ref: "docs/misconceptions.md#misconception-11"
    verify_command: "netstat -an | grep -E '(21|30000)'  # During FTP transfer"

  # ═══════════════════════════════════════════════════════════════════════════
  # LO5: Security Evaluation (Understand + Analyse)
  # ═══════════════════════════════════════════════════════════════════════════
  - id: q09
    lo_ref: LO5
    bloom_level: understand
    difficulty: intermediate
    stem: "Why is SSH key authentication more secure than password authentication?"
    options:
      a: "SSH keys are encrypted, passwords are not"
      b: "SSH keys are longer and never transmitted to the server"
      c: "SSH keys expire automatically, passwords do not"
      d: "SSH keys use symmetric encryption, passwords use asymmetric"
    correct: b
    explanation: |
      SSH keys provide 2048+ bits of entropy vs typical passwords (40-80 bits).
      Only the public key is sent to the server — the private key never leaves
      the client. This makes brute-force attacks impractical and eliminates
      phishing risks since there's no password to steal.
    misconception_ref: "docs/misconceptions.md#misconception-10"

  - id: q10
    lo_ref: LO5
    bloom_level: analyse
    difficulty: advanced
    stem: |
      You capture network traffic and see FTP credentials in plaintext.
      Which statement is correct?
    options:
      a: "This is normal — FTP always encrypts after authentication"
      b: "The FTP server is misconfigured and should use TLS"
      c: "Standard FTP transmits everything in plaintext including credentials"
      d: "Only passive mode FTP exposes credentials"
    correct: c
    explanation: |
      Standard FTP (port 21) transmits all data in plaintext, including
      USER and PASS commands. FTPS (FTP over TLS) or SFTP (SSH File Transfer)
      should be used when security is required. This is why FTP is considered
      insecure for sensitive data.
    verify_command: "# Capture FTP: tcpdump -i any port 2121 -A | grep -E '(USER|PASS)'"

# ═══════════════════════════════════════════════════════════════════════════════
# ANSWER_KEY (for instructor reference)
# ═══════════════════════════════════════════════════════════════════════════════
answer_key:
  q01: b
  q02: c
  q03: b
  q04: b
  q05: b
  q06: c
  q07: b
  q08: b
  q09: b
  q10: c

# ═══════════════════════════════════════════════════════════════════════════════
# LO MAPPING SUMMARY
# ═══════════════════════════════════════════════════════════════════════════════
lo_question_map:
  LO1: [q01, q02]      # TLS certificates
  LO2: [q03, q04, q05] # REST Richardson levels
  LO3: [q06, q07]      # DNS query structure
  LO4: [q08]           # Protocol implementation
  LO5: [q09, q10]      # Security evaluation
