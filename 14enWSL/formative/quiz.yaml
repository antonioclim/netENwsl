# ═══════════════════════════════════════════════════════════════════════════════
# Formative Quiz — Week 14: Integrated Recap and Project Evaluation
# ═══════════════════════════════════════════════════════════════════════════════
# NETWORKING class — ASE, CSIE | Computer Networks Laboratory
# by ing. dr. Antonio Clim
#
# Format: Standardised YAML for self-assessment
# Compatible with: run_quiz.py, JSON export, Moodle/Canvas LMS
# Version: 2.1.0
# Language: British English
# ═══════════════════════════════════════════════════════════════════════════════

metadata:
  week: 14
  topic: "Integrated Recap and Project Evaluation"
  version: "2.1.0"
  author: "ing. dr. Antonio Clim"
  institution: "ASE Bucharest, CSIE"
  course: "Computer Networks"
  language: "en-GB"
  estimated_time_minutes: 25
  passing_score_percent: 70
  total_points: 42
  question_count: 15
  
  # LMS Export Configuration
  lms_export:
    moodle_compatible: true
    canvas_compatible: true
    export_formats: ["xml", "json", "qti"]
  
  bloom_coverage:
    - level: "Remember"
      count: 3
      points: 3
    - level: "Understand"
      count: 3
      points: 6
    - level: "Apply"
      count: 2
      points: 4
    - level: "Analyse"
      count: 2
      points: 6
    - level: "Evaluate"
      count: 2
      points: 8
    - level: "Create"
      count: 3
      points: 15
      
  learning_objectives:
    LO1:
      description: "Recall OSI and TCP/IP layered architectures"
      bloom_level: "Remember"
    LO2:
      description: "Explain reverse proxies and load balancers"
      bloom_level: "Understand"
    LO3:
      description: "Implement multi-container Docker environment"
      bloom_level: "Apply"
    LO4:
      description: "Analyse packet captures to trace HTTP flows"
      bloom_level: "Analyse"
    LO5:
      description: "Design verification strategies for network services"
      bloom_level: "Create"
    LO6:
      description: "Evaluate system behaviour under various conditions"
      bloom_level: "Evaluate"

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTIONS
# ═══════════════════════════════════════════════════════════════════════════════

questions:

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 1: REMEMBER (3 questions, 1 point each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q01
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "Which OSI layer is responsible for logical addressing (IP)?"
    
    options:
      a: "Data Link (Layer 2)"
      b: "Network (Layer 3)"
      c: "Transport (Layer 4)"
      d: "Application (Layer 7)"
      
    correct: "b"
    
    explanation: |
      The Network Layer (Layer 3) manages IP addressing and packet routing 
      between different networks.
      - Data Link (L2) uses MAC addresses for local communication
      - Transport (L4) uses ports (not addresses)
      - Application (L7) handles application data
      
    misconception_ref: "docs/misconceptions.md#misconception-1"

  - id: q02
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "How many packets are exchanged in a TCP three-way handshake?"
    
    options:
      a: "2"
      b: "3"
      c: "4"
      d: "5"
      
    correct: "b"
    
    explanation: |
      The TCP three-way handshake involves exactly 3 packets:
      1. SYN (client → server)
      2. SYN-ACK (server → client)
      3. ACK (client → server)
      
    misconception_ref: "docs/misconceptions.md#misconception-3"

  - id: q03
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "Which protocol provides reliable, ordered delivery of data?"
    
    options:
      a: "UDP"
      b: "IP"
      c: "TCP"
      d: "ICMP"
      
    correct: "c"
    
    explanation: |
      TCP (Transmission Control Protocol) provides:
      - Reliable delivery (acknowledgements and retransmissions)
      - Ordered delivery (sequence numbers)
      - Flow control and congestion control
      
      UDP is connectionless and does not guarantee delivery or order.
      
    misconception_ref: "docs/misconceptions.md#misconception-2"

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 2: UNDERSTAND (3 questions, 2 points each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q04
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO2"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      A load balancer is configured with round-robin algorithm and two backends.
      After sending 6 requests, what is the expected distribution?
    
    options:
      a: "Random distribution depending on server load"
      b: "All 6 requests to the first backend"
      c: "3 requests to each backend"
      d: "Distribution based on response time"
      
    correct: "c"
    
    explanation: |
      Round-robin distributes requests in a deterministic alternating pattern:
      Request 1 → Backend 1
      Request 2 → Backend 2
      Request 3 → Backend 1
      ...and so on.
      
      After 6 requests: 3 to each backend (50/50 split).
      
    misconception_ref: "docs/misconceptions.md#misconception-8"

  - id: q05
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO2"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      In Docker Compose, if a service defines "ports: ['8080:80']", 
      what does this mapping mean?
    
    options:
      a: "Container port 8080 maps to host port 80"
      b: "Host port 8080 maps to container port 80"
      c: "Both ports 8080 and 80 are exposed"
      d: "Port 8080 is used internally, 80 externally"
      
    correct: "b"
    
    explanation: |
      Docker port mapping format is HOST:CONTAINER
      - '8080:80' means: host port 8080 → container port 80
      - Access via localhost:8080, which forwards to container's port 80
      
    misconception_ref: "docs/misconceptions.md#misconception-5"

  - id: q06
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO1"
    difficulty: "intermediate"
    points: 2
    
    stem: "What is the primary purpose of the Transport layer in the TCP/IP model?"
    
    options:
      a: "Routing packets between networks"
      b: "End-to-end communication between applications"
      c: "Physical transmission of bits"
      d: "Domain name resolution"
      
    correct: "b"
    
    explanation: |
      The Transport layer provides end-to-end communication between applications:
      - Uses port numbers to identify applications
      - TCP provides reliable streams
      - UDP provides datagrams
      
      Routing is handled by the Network layer (IP).
      
    misconception_ref: "docs/misconceptions.md#misconception-2"

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 3: APPLY (2 questions, 2 points each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q07
    type: multiple_choice
    bloom_level: "Apply"
    lo_ref: "LO3"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      Which Docker command shows only running containers with names 
      starting with "week14"?
    
    options:
      a: "docker ps | grep week14"
      b: "docker ps -a --filter name=week14"
      c: "docker ps --filter name=^week14"
      d: "docker container list week14*"
      
    correct: "c"
    
    explanation: |
      The correct command uses:
      - docker ps (shows running containers only)
      - --filter name=^week14 (regex anchor for "starts with")
      
      Option A works but is less efficient (pipes through grep).
      Option B includes stopped containers (-a flag).
      
    misconception_ref: "docs/misconceptions.md#misconception-6"

  - id: q08
    type: multiple_choice
    bloom_level: "Apply"
    lo_ref: "LO4"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      In Wireshark, which display filter shows only HTTP traffic 
      to or from port 8080?
    
    options:
      a: "http.port == 8080"
      b: "tcp.port == 8080 && http"
      c: "tcp.port == 8080"
      d: "port 8080"
      
    correct: "c"
    
    explanation: |
      For HTTP on non-standard ports:
      - tcp.port == 8080 captures all TCP traffic on that port
      - http filter only works for port 80 by default
      - "port 8080" is capture filter syntax (BPF), not display filter
      
      In Wireshark display filters, tcp.port matches both src and dst.
      
    misconception_ref: "docs/misconceptions.md#misconception-4"

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 4: ANALYSE (2 questions, 3 points each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q09
    type: multiple_choice
    bloom_level: "Analyse"
    lo_ref: "LO4"
    difficulty: "advanced"
    points: 3
    
    stem: |
      A packet capture shows: SYN, SYN-ACK, ACK, HTTP GET, HTTP 200, FIN, ACK, FIN, ACK.
      How many TCP connections were established?
    
    options:
      a: "1"
      b: "2"
      c: "3"
      d: "Cannot determine"
      
    correct: "a"
    
    explanation: |
      Analysing the sequence:
      - SYN, SYN-ACK, ACK = 1 connection established (3-way handshake)
      - HTTP GET, HTTP 200 = data exchange
      - FIN, ACK, FIN, ACK = connection termination (4-way)
      
      This represents a single complete TCP connection lifecycle.
      
    misconception_ref: "docs/misconceptions.md#misconception-3"

  - id: q10
    type: multiple_choice
    bloom_level: "Analyse"
    lo_ref: "LO6"
    difficulty: "advanced"
    points: 3
    
    stem: |
      After stopping one backend, the load balancer returns 502 errors 
      for ~50% of requests. What is the most likely cause?
    
    options:
      a: "Load balancer crash"
      b: "Round-robin still routing to dead backend"
      c: "Network congestion"
      d: "DNS resolution failure"
      
    correct: "b"
    
    explanation: |
      The 50% error rate matches round-robin behaviour:
      - Requests to healthy backend succeed
      - Requests to dead backend fail (502 Bad Gateway)
      
      The LB has not yet detected the backend failure 
      (health check interval not elapsed).
      
    misconception_ref: "docs/misconceptions.md#misconception-9"

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 5: EVALUATE (2 questions, 4 points each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q11
    type: multiple_choice
    bloom_level: "Evaluate"
    lo_ref: "LO6"
    difficulty: "advanced"
    points: 4
    
    stem: |
      A system shows: Backend 1 receives 70% of requests, Backend 2 receives 30%.
      The load balancer is configured for round-robin. Which explanation is MOST likely?
    
    options:
      a: "Bug in the load balancer algorithm"
      b: "Sticky sessions enabled for some clients"
      c: "Backend 2 has slower response times"
      d: "Network packet loss to Backend 2"
      
    correct: "b"
    
    explanation: |
      Evaluating each possibility:
      - A: Unlikely - round-robin is simple and well-tested
      - B: MOST LIKELY - sticky sessions override round-robin for returning clients
      - C: Response time does not affect round-robin selection
      - D: Would cause errors, not skewed distribution
      
      Sticky sessions (session affinity) are common for stateful applications.
      
    misconception_ref: "docs/misconceptions.md#misconception-9"

  - id: q12
    type: multiple_choice
    bloom_level: "Evaluate"
    lo_ref: "LO5"
    difficulty: "advanced"
    points: 4
    
    stem: |
      Which verification approach provides the HIGHEST confidence that 
      a containerised service is functioning correctly?
    
    options:
      a: "Check container status with 'docker ps'"
      b: "Verify port is open with 'netstat'"
      c: "Send test request and validate response content"
      d: "Check container logs for errors"
      
    correct: "c"
    
    explanation: |
      Evaluating verification depth:
      - A: Only confirms container is running (not that service works)
      - B: Only confirms port is listening (not that service responds correctly)
      - C: BEST - validates entire request/response path with expected behaviour
      - D: Absence of errors does not prove correct function
      
      End-to-end testing with response validation is the gold standard.
      
    misconception_ref: "docs/misconceptions.md#misconception-7"

  # ═══════════════════════════════════════════════════════════════════════════
  # BLOOM LEVEL 6: CREATE (3 questions, 5 points each)
  # ═══════════════════════════════════════════════════════════════════════════
  
  - id: q13
    type: multiple_choice
    bloom_level: "Create"
    lo_ref: "LO5"
    difficulty: "advanced"
    points: 5
    
    stem: |
      Design a health check strategy for a load-balanced web application.
      Which combination provides the BEST coverage?
    
    options:
      a: "TCP port check every 5 seconds"
      b: "HTTP GET to /health endpoint with 200 OK validation"
      c: "HTTP GET to /health with response body validation and timeout"
      d: "ICMP ping to backend IPs"
      
    correct: "c"
    
    explanation: |
      Creating effective health checks requires:
      - HTTP (not just TCP) to verify application layer
      - Dedicated /health endpoint (not /)
      - Response body validation (not just status code)
      - Timeout handling (detect hung processes)
      
      Option C combines all these elements for robust detection.
      
    misconception_ref: "docs/misconceptions.md#misconception-7"

  - id: q14
    type: multiple_choice
    bloom_level: "Create"
    lo_ref: "LO3"
    difficulty: "advanced"
    points: 5
    
    stem: |
      Design a Docker Compose network topology for: 2 backend servers, 
      1 load balancer (public) and 1 database (private). 
      Which design is MOST secure?
    
    options:
      a: "All containers on default bridge network"
      b: "Single custom network for all containers"
      c: "Frontend network (LB + backends) and backend network (backends + DB)"
      d: "Each container on its own network"
      
    correct: "c"
    
    explanation: |
      Creating secure network topology:
      - LB needs to reach backends (frontend network)
      - Backends need to reach DB (backend network)
      - DB should NOT be accessible from LB (isolation)
      
      Option C provides proper network segmentation:
      - LB → frontend_net → Backends
      - Backends → backend_net → DB
      - DB isolated from direct LB access
      
    misconception_ref: "docs/misconceptions.md#misconception-6"

  - id: q15
    type: multiple_choice
    bloom_level: "Create"
    lo_ref: "LO5"
    difficulty: "advanced"
    points: 5
    
    stem: |
      Create a troubleshooting procedure for "Connection refused" errors 
      when accessing http://localhost:8080. What is the CORRECT order?
    
    options:
      a: "Check firewall → Check DNS → Check container → Check port"
      b: "Check container running → Check port mapping → Check service logs → Check firewall"
      c: "Check DNS → Check container → Check firewall → Check logs"
      d: "Check logs → Check container → Check network → Check DNS"
      
    correct: "b"
    
    explanation: |
      Creating systematic troubleshooting procedure:
      1. Container running? (docker ps)
      2. Port mapping correct? (docker port / compose config)
      3. Service started inside container? (docker logs)
      4. Firewall blocking? (iptables / ufw)
      
      This follows the OSI model from application down to network.
      DNS is not relevant for localhost connections.
      
    misconception_ref: "docs/misconceptions.md#misconception-10"

# ═══════════════════════════════════════════════════════════════════════════════
# METADATA FOOTER
# ═══════════════════════════════════════════════════════════════════════════════
#
# Document version: 2.1.0 | Week 14: Integrated Recap | January 2025
# NETWORKING class — ASE, CSIE | by ing. dr. Antonio Clim
#
# Cumulative Export Formats:
#   - YAML: This file (run with run_quiz.py)
#   - JSON: formative/quiz.json (LMS compatible)
#   - Moodle XML: Generated via export_moodle.py
#   - Canvas QTI: Generated via export_moodle.py --format qti
#
# ═══════════════════════════════════════════════════════════════════════════════
