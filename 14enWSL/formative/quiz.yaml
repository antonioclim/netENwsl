# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Formative Quiz â€” Week 14: Integrated Recap and Project Evaluation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NETWORKING class â€” ASE, CSIE | Computer Networks Laboratory
# by ing. dr. Antonio Clim
#
# Format: Standardised YAML for self-assessment
# Compatible with: run_quiz.py, JSON export, Moodle/Canvas LMS
# Version: 2.0.0
# Language: British English
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

metadata:
  week: 14
  topic: "Integrated Recap and Project Evaluation"
  version: "2.0.0"
  author: "ing. dr. Antonio Clim"
  institution: "ASE Bucharest, CSIE"
  course: "Computer Networks"
  language: "en-GB"
  estimated_time_minutes: 25
  passing_score_percent: 70
  total_points: 42
  question_count: 15
  
  bloom_coverage:
    - level: "Remember"
      count: 3
      points: 3
    - level: "Understand"
      count: 3
      points: 6
    - level: "Apply"
      count: 2
      points: 4
    - level: "Analyse"
      count: 2
      points: 6
    - level: "Evaluate"
      count: 2
      points: 8
    - level: "Create"
      count: 3
      points: 15
      
  learning_objectives:
    LO1:
      description: "Recall OSI and TCP/IP layered architectures"
      bloom_level: "Remember"
    LO2:
      description: "Explain reverse proxies and load balancers"
      bloom_level: "Understand"
    LO3:
      description: "Implement multi-container Docker environment"
      bloom_level: "Apply"
    LO4:
      description: "Analyse packet captures to trace HTTP flows"
      bloom_level: "Analyse"
    LO5:
      description: "Design verification strategies for network services"
      bloom_level: "Create"
    LO6:
      description: "Evaluate system behaviour under various conditions"
      bloom_level: "Evaluate"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# QUESTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

questions:

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 1: REMEMBER (3 questions, 1 point each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  - id: q01
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "Which OSI layer is responsible for logical addressing (IP)?"
    
    options:
      a: "Data Link (Layer 2)"
      b: "Network (Layer 3)"
      c: "Transport (Layer 4)"
      d: "Application (Layer 7)"
      
    correct: "b"
    
    explanation: |
      The Network Layer (Layer 3) manages IP addressing and packet routing 
      between different networks.
      - Data Link (L2) uses MAC addresses for local communication
      - Transport (L4) uses ports (not addresses)
      - Application (L7) handles application data
      
    misconception_ref: "docs/misconceptions.md#misconception-1"
    
    verification:
      command: "docker exec week14_client ip addr show eth0"
      expected: "inet 172.21.0.2/24"
      
    hint: "Consider what information a router uses to decide where to send a packet."

  - id: q02
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "What Protocol Data Unit (PDU) does TCP use at Layer 4?"
    
    options:
      a: "Frame"
      b: "Packet"
      c: "Segment"
      d: "Datagram"
      
    correct: "c"
    
    explanation: |
      Each OSI layer has its own PDU:
      - Layer 2 (Data Link): Frame
      - Layer 3 (Network): Packet
      - Layer 4 (Transport): Segment (TCP) or Datagram (UDP)
      - Layer 7 (Application): Data/Message
      
    misconception_ref: "docs/misconceptions.md#misconception-2"
    
    hint: "TCP = Transport Control Protocol â€” which layer?"

  - id: q03
    type: multiple_choice
    bloom_level: "Remember"
    lo_ref: "LO1"
    difficulty: "basic"
    points: 1
    
    stem: "What is the standard port for HTTP (not HTTPS)?"
    
    options:
      a: "22"
      b: "53"
      c: "80"
      d: "443"
      
    correct: "c"
    
    explanation: |
      Common standard ports:
      - 22: SSH (Secure Shell)
      - 53: DNS (Domain Name System)
      - 80: HTTP (HyperText Transfer Protocol)
      - 443: HTTPS (HTTP Secure)
      
    verification:
      command: "curl -I http://localhost:8080/ 2>/dev/null | head -1"
      expected: "HTTP/1.1 200"
      
    hint: "HTTP = HyperText Transfer Protocol. Think of the number 8..."

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 2: UNDERSTAND (3 questions, 2 points each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  - id: q04
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO2"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      A round-robin load balancer has 2 backends (app1, app2).
      If you send 4 consecutive requests, what is the expected distribution?
      
    options:
      a: "All 4 to app1 (sticky session)"
      b: "app1, app2, app1, app2 (deterministic alternation)"
      c: "Random distribution (could be anything)"
      d: "First 2 to app1, next 2 to app2 (batch)"
      
    correct: "b"
    
    explanation: |
      Round-robin is a DETERMINISTIC and SEQUENTIAL algorithm:
      - Request 1 â†’ app1
      - Request 2 â†’ app2
      - Request 3 â†’ app1
      - Request 4 â†’ app2
      
      It is NOT random! With N backends, requests go in order
      1, 2, 3, ..., N, 1, 2, 3, ..., N (wrap-around with modulo).
      
    misconception_ref: "docs/misconceptions.md#misconception-8"
    
    verification:
      command: "for i in 1 2 3 4; do curl -s http://localhost:8080/ | grep -o 'app[12]'; done"
      expected: "app1\napp2\napp1\napp2"
      
    hint: "Round = circle, Robin = in turn. Not 'Random-robin'!"

  - id: q05
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO3"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      In docker-compose.yml you find: ports: "8080:80"
      What does this configuration mean?
      
    options:
      a: "Container listens on port 8080, host on 80"
      b: "Host exposes port 8080, which maps to port 80 in the container"
      c: "Both ports are identical (8080 = 80)"
      d: "Host listens on 80, container on 8080"
      
    correct: "b"
    
    explanation: |
      Docker port mapping syntax is HOST:CONTAINER
      
      "8080:80" means:
      - From outside (browser): access http://localhost:8080
      - Inside (container): service listens on :80
      
      Memory aid: "Left is outside, Right is inside" 
      (read left to right, like traffic entering)
      
    misconception_ref: "docs/misconceptions.md#misconception-5"
    
    verification:
      command: "docker port week14_lb"
      expected: "8080/tcp -> 0.0.0.0:8080"
      
    hint: "HOST:CONTAINER â€” what is on the left is for the outside."

  - id: q06
    type: multiple_choice
    bloom_level: "Understand"
    lo_ref: "LO1"
    difficulty: "intermediate"
    points: 2
    
    stem: "What is the correct sequence of flags in the TCP three-way handshake?"
    
    options:
      a: "SYN â†’ ACK â†’ SYN-ACK"
      b: "SYN â†’ SYN-ACK â†’ ACK"
      c: "ACK â†’ SYN â†’ SYN-ACK"
      d: "SYN â†’ SYN â†’ ACK"
      
    correct: "b"
    
    explanation: |
      TCP Three-Way Handshake:
      
      Client                    Server
        |                         |
        |--- SYN (seq=x) -------->|  Step 1: "I want to connect"
        |                         |
        |<-- SYN-ACK (ack=x+1) ---|  Step 2: "OK, I also want to"
        |      (seq=y)            |
        |                         |
        |--- ACK (ack=y+1) ------>|  Step 3: "Confirmed!"
        |                         |
        [Connection established]
      
    misconception_ref: "docs/misconceptions.md#misconception-3"
    
    hint: "Both sides need to synchronise â€” hence SYN from both."

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 3: APPLY (2 questions, 2 points each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  - id: q07
    type: fill_blank
    bloom_level: "Apply"
    lo_ref: "LO3"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      To see all Docker containers currently running,
      the complete command is: docker ___
      
    correct:
      - "ps"
      - "container ls"
      - "container list"
      
    case_sensitive: false
    
    explanation: |
      Equivalent commands for listing active containers:
      - docker ps                    (short, traditional)
      - docker container ls          (new, explicit)
      - docker container list        (alias for ls)
      
      To see ALL containers (including stopped): docker ps -a
      
    verification:
      command: "docker ps --format '{{.Names}}' | grep week14"
      expected: "week14_app1, week14_app2, week14_lb, etc."
      
    hint: "ps = process status (traditional Unix abbreviation)"

  - id: q08
    type: fill_blank
    bloom_level: "Apply"
    lo_ref: "LO4"
    difficulty: "intermediate"
    points: 2
    
    stem: |
      In Wireshark, to filter only HTTP packets with GET method,
      the correct display filter is: http.request.method == "___"
      
    correct:
      - "GET"
      
    case_sensitive: true
    
    explanation: |
      Wireshark display filters for HTTP:
      - http.request.method == "GET"     (GET requests)
      - http.request.method == "POST"    (POST requests)
      - http.response.code == 200        (successful responses)
      - http.host contains "example"     (specific host)
      
      NOTE: Values are case-sensitive! "GET" not "get".
      
    verification:
      command: "# In Wireshark: Apply filter, then verify in packet list"
      expected: "Only packets with Info: GET /..."
      
    hint: "HTTP methods are always UPPERCASE: GET, POST, PUT, DELETE..."

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 4: ANALYSE (2 questions, 3 points each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  - id: q09
    type: multiple_choice
    bloom_level: "Analyse"
    lo_ref: "LO4"
    difficulty: "advanced"
    points: 3
    
    stem: |
      In Wireshark, you capture traffic and observe the following TCP sequence:
      
      Packet 1: [SYN] 192.168.1.10:54321 â†’ 10.0.0.5:8080
      Packet 2: [RST, ACK] 10.0.0.5:8080 â†’ 192.168.1.10:54321
      
      What does this sequence indicate?
      
    options:
      a: "Connection established successfully, data transfer follows"
      b: "Port 8080 on server 10.0.0.5 is closed or no service exists"
      c: "Network timeout â€” packets were lost"
      d: "Firewall blocked the connection silently (drop)"
      
    correct: "b"
    
    explanation: |
      Sequence analysis:
      
      [SYN] â†’ Client attempts to initiate connection
      [RST, ACK] â† Server responds IMMEDIATELY with Reset
      
      RST (Reset) immediately after SYN indicates:
      - Destination port is CLOSED
      - No service is listening on that port
      - Server kernel responds automatically with RST
      
      Differences from other scenarios:
      - Firewall DROP: You would receive NOTHING back (timeout)
      - Firewall REJECT: You would receive ICMP "port unreachable"
      - Service busy: You would receive SYN-ACK (connection in progress)
      
    misconception_ref: "docs/code_tracing.md#exercise-t1"
    
    verification:
      command: "# Test: nc -zv localhost 9999 (closed port)"
      expected: "Connection refused"
      
    hint: "RST = Reset = 'Nobody here!'"

  - id: q10
    type: multiple_choice
    bloom_level: "Analyse"
    lo_ref: "LO6"
    difficulty: "advanced"
    points: 3
    
    stem: |
      You access http://localhost:8080/ and receive the response:
      
      HTTP/1.1 502 Bad Gateway
      X-Error: upstream connection failed
      
      What is the most likely cause and first diagnostic step?
      
    options:
      a: "Client sent a malformed request â†’ check the request"
      b: "Backends are down or not responding â†’ check docker ps and health"
      c: "Load balancer is overloaded â†’ check CPU/memory"
      d: "SSL certificate has expired â†’ check certificates"
      
    correct: "b"
    
    explanation: |
      HTTP 502 Bad Gateway means:
      
      "The proxy (load balancer) could NOT obtain a valid response 
       from upstream server (backends)"
      
      Common causes:
      1. Backends are stopped (docker ps does not show them running)
      2. Backends are not responding (health check fails)
      3. Network connectivity between LB and backends is broken
      4. Backends return errors (500, timeout)
      
      First diagnostic step:
      ```bash
      docker ps | grep week14_app      # Check if running
      curl http://localhost:8001/health # Test app1 directly
      curl http://localhost:8002/health # Test app2 directly
      docker logs week14_lb            # Check LB logs
      ```
      
    misconception_ref: "docs/troubleshooting.md#load-balancer-issues"
    
    verification:
      command: "curl -s http://localhost:8080/lb-status"
      expected: "healthy backends listed"
      
    hint: "502 = 'I tried to ask the backend, but it did not respond'"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 5: EVALUATE (2 questions, 4 points each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  - id: q11
    type: multiple_choice
    bloom_level: "Evaluate"
    lo_ref: "LO6"
    difficulty: "advanced"
    points: 4
    
    stem: |
      You implemented a round-robin load balancer with 3 backends.
      After 1 hour of operation, you observe the following distribution:
      
      - app1: 45% of requests
      - app2: 35% of requests  
      - app3: 20% of requests
      
      What is the most likely cause of this uneven distribution?
      
    options:
      a: "The round-robin algorithm is defective and needs replacement"
      b: "app3 was periodically unavailable and LB removed it from rotation"
      c: "Clients prefer app1 and app2 due to lower latency"
      d: "Round-robin does not guarantee equal distribution over time"
      
    correct: "b"
    
    explanation: |
      Distribution analysis:
      
      Round-robin GUARANTEES equal distribution if all backends are available.
      Distribution 45/35/20 suggests app3 was unavailable ~40% of the time.
      
      Mathematical calculation:
      - If all 3 were up: 33.3% each
      - app3 at 20% means it was down ~40% of the time
      - During that time, app1 and app2 received 50/50
      - Result: ~45% / ~35% / ~20%
      
      Verification:
      ```bash
      # Check backend uptime
      docker logs week14_app3 | grep -c "started"
      docker logs week14_app3 | grep -c "error"
      ```
      
    misconception_ref: "docs/misconceptions.md#misconception-8"
    
    evaluation_criteria: |
      - Identifies that round-robin is deterministic
      - Deduces that the problem is availability, not algorithm
      - Can calculate approximate downtime from distribution
      
    hint: "Round-robin is deterministic. If distribution is unequal, what changed?"

  - id: q12
    type: scenario_analysis
    bloom_level: "Evaluate"
    lo_ref: "LO5"
    difficulty: "advanced"
    points: 4
    
    stem: |
      You are responsible for diagnosing a network problem.
      You have the following data:
      
      1. `curl http://localhost:8080/` returns timeout after 30s
      2. `docker ps` shows all containers as "Up" and "healthy"
      3. `docker exec week14_client ping -c 1 172.21.0.10` returns success
      4. `docker logs week14_lb` shows "upstream connection refused"
      
      Evaluate this information and identify the problem.
      
    options:
      a: "Load balancer is not starting â€” needs restart"
      b: "Problem is with backends: either not listening or wrong port"
      c: "Firewall is blocking HTTP traffic"
      d: "DNS resolution failure in Docker network"
      
    correct: "b"
    
    explanation: |
      Systematic analysis of clues:
      
      âœ… Clue 1: Timeout = request reaches LB but does not receive response
      âœ… Clue 2: Containers healthy = health checks pass (but may be superficial)
      âœ… Clue 3: Ping works = network connectivity OK
      ğŸ”´ Clue 4: "upstream connection refused" = LB cannot connect to backends
      
      "Connection refused" means:
      - Backend receives SYN
      - Backend responds with RST
      - = Nobody is listening on that port
      
      Verification:
      ```bash
      # Check what backends are listening on
      docker exec week14_app1 ss -tlnp
      docker exec week14_app2 ss -tlnp
      # Compare with LB upstream config
      docker exec week14_lb cat /etc/nginx/nginx.conf | grep upstream -A 5
      ```
      
    evaluation_criteria: |
      - Analyses all clues systematically
      - Identifies the decisive clue (LB log)
      - Proposes correct diagnosis

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BLOOM LEVEL 6: CREATE (3 questions, 5 points each)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  - id: q13
    type: design_task
    bloom_level: "Create"
    lo_ref: "LO5"
    difficulty: "expert"
    points: 5
    
    stem: |
      Design an automated test that verifies the load balancer 
      distributes traffic correctly between backends.
      
      Requirements:
      1. Test must be deterministic (same result every run)
      2. Must verify distribution, not just connectivity
      3. Must report which backend handled each request
      
      Complete the function below:
      
    code_template: |
      def test_load_balancer_distribution():
          """
          Verify round-robin distribution of the load balancer.
          
          Returns:
              bool: True if distribution is correct
          """
          import urllib.request
          
          results = []
          num_requests = ___  # Q1: How many requests for a valid test?
          
          for i in range(num_requests):
              response = urllib.request.urlopen('http://localhost:8080/')
              body = response.read().decode()
              backend = ___  # Q2: How do you extract the backend name?
              results.append(backend)
          
          # Q3: How do you verify round-robin distribution?
          expected = ___
          
          return results == expected
    
    correct:
      q1: ["4", "6", "8"]
      q2: ["'app1' if 'app1' in body else 'app2'", "body.split()[0]"]
      q3: ["['app1', 'app2', 'app1', 'app2']", "['app1', 'app2'] * (num_requests // 2)"]
    
    explanation: |
      Design decisions:
      
      1. **Number of requests**: Multiple of 2 (number of backends) for exact verification
         - 4 requests = verify 2 complete cycles
         - More = more robust but slower
      
      2. **Extract backend**: Parse response body for identifier
         - Backends return their name in response
         - Alternative: X-Backend header
      
      3. **Verify distribution**: 
         - Round-robin = deterministic sequence
         - ['app1', 'app2', 'app1', 'app2'] for 4 requests
         
      Complete implementation:
      ```python
      def test_load_balancer_distribution():
          import urllib.request
          
          results = []
          num_requests = 4
          
          for i in range(num_requests):
              response = urllib.request.urlopen('http://localhost:8080/')
              body = response.read().decode()
              backend = 'app1' if 'app1' in body.lower() else 'app2'
              results.append(backend)
          
          expected = ['app1', 'app2', 'app1', 'app2']
          return results == expected
      ```
      
    rubric:
      5: "Correct completion + design decisions explanation"
      4: "Correct completion without explanation"
      3: "2 of 3 correct"
      2: "1 of 3 correct"
      0: "Incorrect or empty"

  - id: q14
    type: architecture_design
    bloom_level: "Create"
    lo_ref: "LO3"
    difficulty: "expert"
    points: 5
    
    stem: |
      Design an extension to the Week 14 topology that adds:
      1. A third backend (app3) on 172.20.0.4
      2. A monitoring service (monitor) that checks health of all services
      3. Network isolation: monitor can see everything but apps cannot see each other
      
      Complete the docker-compose.yml fragment:
      
    code_template: |
      services:
        app3:
          image: week14/backend
          container_name: week14_app3
          networks:
            backend_net:
              ipv4_address: ___  # Q1
          environment:
            - APP_NAME=app3
            
        monitor:
          image: week14/monitor
          container_name: week14_monitor
          networks:
            - ___  # Q2: Which networks should it be on?
            - ___
          depends_on:
            - ___  # Q3: Which services does it depend on?
            
      networks:
        # Q4: How do you ensure isolation between apps?
        backend_net:
          driver: bridge
          internal: ___
          ipam:
            config:
              - subnet: 172.20.0.0/24
    
    correct:
      q1: "172.20.0.4"
      q2: ["backend_net", "frontend_net"]
      q3: ["app1", "app2", "app3", "lb"]
      q4: "false"
    
    explanation: |
      Design considerations:
      
      1. **IP app3**: 172.20.0.4 follows existing scheme (app1=.2, app2=.3)
      
      2. **Monitor networks**: Must be on BOTH networks to see all services
         - backend_net: sees app1, app2, app3
         - frontend_net: sees lb, client
      
      3. **Dependencies**: Monitor depends on services it monitors
      
      4. **Isolation**: 
         - `internal: true` = no external access (not applicable here)
         - Isolation between apps is done by NOT putting them on same network
         - Docker default: containers on same network can communicate
         
      For real isolation between apps, separate networks would be needed:
      ```yaml
      networks:
        app1_net:
          internal: true
        app2_net:
          internal: true
        lb_net:
          # LB connected to all
      ```

  - id: q15
    type: troubleshooting_design
    bloom_level: "Create"
    lo_ref: "LO5"
    difficulty: "expert"
    points: 5
    
    stem: |
      Create a troubleshooting checklist for the scenario:
      "HTTP requests intermittently return 502 Bad Gateway"
      
      Requirements:
      1. Minimum 5 diagnostic steps
      2. Each step with a concrete command
      3. Logical order (simple to complex)
      4. Include interpretation of results
      
    format: "open_response"
    
    correct_elements:
      - "Check if all containers are running: docker ps"
      - "Check backend health: curl localhost:8001/health"
      - "Check LB logs: docker logs week14_lb"
      - "Check network connectivity: docker exec week14_lb ping app1"
      - "Check backend logs: docker logs week14_app1"
      - "Check resource usage: docker stats"
      - "Verify port mappings: docker port week14_lb"
    
    rubric:
      5: "5+ correct steps, logically ordered, with interpretations"
      4: "5 correct steps but suboptimal order"
      3: "3-4 correct steps"
      2: "1-2 correct steps"
      0: "Incorrect or missing steps"
    
    model_answer: |
      ## Troubleshooting Checklist: Intermittent 502 Bad Gateway
      
      ### Step 1: Verify Container Status
      ```bash
      docker ps --filter name=week14
      ```
      **Interpret**: All containers should show "Up" and "healthy"
      **If failing**: `docker start week14_app1 week14_app2`
      
      ### Step 2: Check Backend Health Directly
      ```bash
      curl -s http://localhost:8001/health
      curl -s http://localhost:8002/health
      ```
      **Interpret**: Should return 200 OK with health status
      **If failing**: Backend application issue, check Step 5
      
      ### Step 3: Examine Load Balancer Logs
      ```bash
      docker logs week14_lb --since 5m | grep -E "(error|502|upstream)"
      ```
      **Interpret**: Look for "upstream connection refused" or timeout messages
      **If errors**: Note timestamp correlation with 502s
      
      ### Step 4: Test Internal Network Connectivity
      ```bash
      docker exec week14_lb ping -c 3 app1
      docker exec week14_lb ping -c 3 app2
      ```
      **Interpret**: Should succeed with <1ms latency
      **If failing**: Network configuration issue
      
      ### Step 5: Check Backend Application Logs
      ```bash
      docker logs week14_app1 --since 5m
      docker logs week14_app2 --since 5m
      ```
      **Interpret**: Look for exceptions, crashes or restart messages
      **If errors**: Application bug or resource exhaustion

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SCORING CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

scoring:
  total_points: 42
  passing_threshold: 29
  
  bloom_distribution:
    Remember: 
      questions: 3
      points: 3
      percentage: 7
    Understand: 
      questions: 3
      points: 6
      percentage: 14
    Apply: 
      questions: 2
      points: 4
      percentage: 10
    Analyse: 
      questions: 2
      points: 6
      percentage: 14
    Evaluate: 
      questions: 2
      points: 8
      percentage: 19
    Create: 
      questions: 3
      points: 15
      percentage: 36
  
  grade_boundaries:
    A_plus:
      min_points: 40
      min_percent: 95
      label: "Excellent"
    A:
      min_points: 36
      min_percent: 85
      label: "Very Good"
    B:
      min_points: 32
      min_percent: 75
      label: "Good"
    C:
      min_points: 29
      min_percent: 70
      label: "Satisfactory"
    D:
      min_points: 25
      min_percent: 60
      label: "Sufficient"
    F:
      min_points: 0
      min_percent: 0
      label: "Insufficient"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FEEDBACK CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

feedback:
  on_pass: |
    Congratulations! You have demonstrated solid understanding of 
    networking concepts covered in this course.
    
    You are prepared for:
    - Final practical assessment
    - Semester project
    
    Continue practising with exercises in src/exercises/!
    
  on_fail: |
    You need more preparation. Here is what to review:
    
    1. Read docs/theory_summary.md for basic concepts
    2. Study docs/misconceptions.md for common errors
    3. Practise with exercises in src/exercises/
    4. Try the quiz again after 30 minutes of study
    
  per_lo_feedback:
    LO1: |
      Review OSI/TCP-IP layers in docs/theory_summary.md section 1.
      Practise: python src/exercises/ex_14_01_review_drills.py --selftest
    LO2: |
      Study load balancing in docs/theory_summary.md section 4.
      Check: docs/misconceptions.md#misconception-8 and #misconception-9
    LO3: |
      Practise Docker networking in docs/theory_summary.md section 8.
      Run: docker network inspect week14_backend_net
    LO4: |
      Practise with Wireshark using filters from docs/commands_cheatsheet.md.
      Capture: python scripts/capture_traffic.py
    LO5: |
      Study docs/troubleshooting.md for verification strategies.
      Try: python tests/smoke_test.py
    LO6: |
      Analyse scenarios from docs/peer_instruction.md.
      Experiment: stop a backend and observe LB behaviour

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXPORT CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export:
  moodle:
    category: "Computer Networks / Week 14"
    question_type_mapping:
      multiple_choice: "multichoice"
      fill_blank: "shortanswer"
      scenario_analysis: "multichoice"
      design_task: "essay"
      architecture_design: "essay"
      troubleshooting_design: "essay"
    shuffle_answers: true
    penalty_factor: 0.25
    
  canvas:
    points_possible: 42
    quiz_type: "practice_quiz"
    time_limit: 25
    allowed_attempts: 3
    
  json:
    include_explanations: true
    include_verification: false
    include_hints: true
    format_version: "2.0"
