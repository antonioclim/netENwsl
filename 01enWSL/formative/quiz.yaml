# formative/quiz.yaml
# Week 1 Formative Assessment — Machine-Readable Format
# NETWORKING class — ASE, CSIE | by ing. dr. Antonio Clim
#
# This file provides programmatically executable quiz questions
# that map directly to Learning Objectives and misconceptions.
#
# Run with: python formative/run_quiz.py
# Export JSON: python formative/run_quiz.py --export-json
# Export Moodle: python formative/run_quiz.py --export-moodle
# Validate: python -c "import yaml; yaml.safe_load(open('formative/quiz.yaml'))"

metadata:
  week: 1
  topic: "Network Fundamentals"
  version: "1.1.0"
  estimated_time_minutes: 25
  passing_score: 70
  total_questions: 22
  bloom_levels:
    remember: 6
    understand: 7
    apply: 7
    analyse: 2
  lo_coverage:
    - LO1  # ICMP ping and latency
    - LO2  # TCP socket communication
    - LO3  # Data parsing
    - LO4  # PCAP analysis
    - LO5  # Transmission delay
    - LO6  # Docker containers
    - LO7  # Wireshark capture
  lms_compatible: true
  export_formats:
    - yaml
    - json
    - moodle_xml
    - canvas_qti

sections:
  - id: pre_lab
    name: "Pre-Lab Quick Check"
    description: "Answer these BEFORE starting the laboratory exercises"
    time_limit_minutes: 5
    questions: [q01, q02, q03, q04, q05]

  - id: during_lab
    name: "During-Lab Checkpoints"
    description: "Verify understanding at key points during the lab"
    time_limit_minutes: 0
    questions: [q06, q07, q08, q09, q10]

  - id: exit_ticket
    name: "Exit Ticket"
    description: "Complete BEFORE leaving the laboratory"
    time_limit_minutes: 10
    questions: [q11, q12, q13, q14, q15]

  - id: full_review
    name: "Full Review"
    description: "Additional questions covering all learning objectives"
    time_limit_minutes: 15
    questions: [q16, q17, q18, q19, q20, q21, q22]

questions:
  # ═══════════════════════════════════════════════════════════════════════════
  # PRE-LAB SECTION (Remember level)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q01
    type: multiple_choice
    lo_ref: LO1
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "What is the difference between latency and bandwidth?"
    options:
      a: "Latency = data volume; Bandwidth = time delay"
      b: "Latency = time delay; Bandwidth = data volume per second"
      c: "They are the same thing measured differently"
      d: "Latency is for TCP; Bandwidth is for UDP"
    correct: b
    explanation: |
      Latency measures TIME (milliseconds) - how long a packet takes to travel.
      Bandwidth measures THROUGHPUT (Mbps) - how much data flows per second.
      Analogy: Latency = pipe length, Bandwidth = pipe width.
    misconception_ref: "docs/misconceptions.md#misconception-1"
    feedback:
      correct: "Correct! Latency = time, Bandwidth = volume/second"
      incorrect: "Review docs/misconceptions.md: Ping measures latency, not bandwidth"

  - id: q02
    type: fill_blank
    lo_ref: LO6
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "The command to show IP addresses in Linux is: ip ___"
    correct: ["addr", "addr show", "a", "address"]
    case_sensitive: false
    explanation: "'ip addr' or 'ip a' displays all network interfaces with their IP addresses"
    hint: "Think about what you want to see - addresses!"
    related_doc: "docs/glossary.md#commands-reference"

  - id: q03
    type: multiple_choice
    lo_ref: LO2
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "What does the LISTEN socket state mean?"
    options:
      a: "The socket is actively transferring data"
      b: "The socket is waiting for incoming connections"
      c: "The socket has encountered an error"
      d: "The socket is in the process of closing"
    correct: b
    explanation: |
      LISTEN means a server socket is ready and waiting for clients to connect.
      No data is being transferred yet - it's just waiting.
      After a client connects, the state changes to ESTABLISHED.
    misconception_ref: "docs/misconceptions.md#misconception-11"
    feedback:
      correct: "Correct! LISTEN = waiting, ESTABLISHED = communicating"
      incorrect: "LISTEN means waiting, not communicating. See socket states diagram."

  - id: q04
    type: multiple_choice
    lo_ref: LO6
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "In Docker, what is the difference between an image and a container?"
    options:
      a: "Image = running instance; Container = read-only template"
      b: "Image = read-only template; Container = running instance"
      c: "They are the same thing with different names"
      d: "Images are for Windows; Containers are for Linux"
    correct: b
    explanation: |
      Image = Read-only template (like a class in programming)
      Container = Running instance of an image (like an object)
      You can create multiple containers from one image.
    misconception_ref: "docs/misconceptions.md#misconception-7"
    related_doc: "docs/glossary.md#docker-terms"

  - id: q05
    type: numeric
    lo_ref: LO6
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "What port does Portainer use by default in our lab environment?"
    correct: 9000
    tolerance: 0
    explanation: "Portainer runs on port 9000 (http://localhost:9000). This port is RESERVED!"
    hint: "It's a 4-digit number starting with 9"
    warning: "Never use port 9000 for lab services!"

  # ═══════════════════════════════════════════════════════════════════════════
  # DURING-LAB SECTION (Understand level)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q06
    type: true_false
    lo_ref: LO1
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "A ping to localhost (127.0.0.1) travels through the physical network interface."
    correct: false
    explanation: |
      Loopback traffic (127.0.0.1) never leaves the machine. It uses the
      virtual loopback interface (lo) and stays entirely within the kernel's
      network stack. This is why loopback pings have <1ms latency.
    misconception_ref: "docs/misconceptions.md#misconception-3"

  - id: q07
    type: multiple_choice
    lo_ref: LO2
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "In the TCP three-way handshake, what flag combination does the server send in response to a SYN?"
    options:
      a: "ACK only"
      b: "SYN only"
      c: "SYN and ACK (SYN-ACK)"
      d: "FIN and ACK"
    correct: c
    explanation: |
      The three-way handshake sequence:
      1. Client sends SYN (synchronise)
      2. Server responds with SYN-ACK (synchronise + acknowledge)
      3. Client sends ACK (acknowledge)
      This establishes the connection with both sides synchronised.

  - id: q08
    type: multiple_choice
    lo_ref: LO2
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "Why does TCP use sequence numbers?"
    options:
      a: "To encrypt the data"
      b: "To identify the sender"
      c: "To ensure ordered delivery and detect missing segments"
      d: "To compress the payload"
    correct: c
    explanation: |
      Sequence numbers allow TCP to:
      - Reassemble segments in correct order (packets may arrive out of order)
      - Detect missing segments (gaps in sequence numbers)
      - Detect duplicate segments
      - Calculate round-trip time for congestion control

  - id: q09
    type: fill_blank
    lo_ref: LO6
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "To see ALL containers (including stopped ones), use: docker ps ___"
    correct: ["-a", "--all"]
    case_sensitive: false
    explanation: |
      'docker ps' shows only running containers.
      'docker ps -a' or 'docker ps --all' shows all containers including stopped ones.
    misconception_ref: "docs/misconceptions.md#misconception-8"

  - id: q10
    type: multiple_choice
    lo_ref: LO6
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "If a process inside a Docker container connects to 'localhost', where does it connect?"
    options:
      a: "The Windows host machine"
      b: "The WSL2 virtual machine"
      c: "The container's own loopback interface"
      d: "The Docker host network"
    correct: c
    explanation: |
      Each container has its own network namespace with its own loopback interface.
      'localhost' inside a container refers to that container, not the host.
      To connect to the host, use 'host.docker.internal' or the host's IP.
    misconception_ref: "docs/misconceptions.md#misconception-7"

  # ═══════════════════════════════════════════════════════════════════════════
  # EXIT TICKET SECTION (Apply level)
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q11
    type: fill_blank
    lo_ref: LO1
    bloom_level: apply
    difficulty: intermediate
    points: 1
    stem: "To ping google.com exactly 4 times in Linux, the command is: ping ___ 4 google.com"
    correct: ["-c"]
    case_sensitive: true
    explanation: |
      The -c flag specifies the count of ICMP echo requests to send.
      Without -c, ping runs indefinitely (on Linux) until interrupted with Ctrl+C.
      On Windows, the equivalent flag is -n.

  - id: q12
    type: multiple_choice
    lo_ref: LO2
    bloom_level: apply
    difficulty: intermediate
    points: 1
    stem: "You see 'Connection refused' when trying to connect to a server. What is the most likely cause?"
    options:
      a: "The network cable is unplugged"
      b: "The firewall is blocking the connection"
      c: "No process is listening on that port"
      d: "The server is too busy to accept connections"
    correct: c
    explanation: |
      'Connection refused' specifically means the TCP stack received the SYN
      packet and responded with RST (reset) because nothing is listening on
      that port. A firewall typically causes timeout, not refusal.
      Network issues cause 'Network unreachable' or 'Host unreachable'.

  - id: q13
    type: ordering
    lo_ref: LO6
    bloom_level: apply
    difficulty: intermediate
    points: 2
    stem: "Order these commands to correctly start a lab environment:"
    items:
      - id: a
        text: "docker compose up -d"
      - id: b
        text: "cd /mnt/d/NETWORKING/WEEK1"
      - id: c
        text: "docker ps"
      - id: d
        text: "sudo service docker start"
    correct_order: [d, b, a, c]
    explanation: |
      1. Start Docker service (required after Windows restart)
      2. Navigate to the lab directory
      3. Start containers with docker compose
      4. Verify containers are running with docker ps

  - id: q14
    type: multiple_choice
    lo_ref: LO2
    bloom_level: apply
    difficulty: advanced
    points: 2
    stem: "A TCP connection shows state TIME_WAIT. What does this indicate?"
    options:
      a: "The connection is waiting for the initial handshake"
      b: "The connection is waiting for data from the peer"
      c: "The connection was closed and is waiting before reusing the port"
      d: "The connection has timed out due to network issues"
    correct: c
    explanation: |
      TIME_WAIT occurs after a connection is closed. The socket remains in
      this state for 2*MSL (Maximum Segment Lifetime) to ensure:
      - Any delayed packets from the old connection don't interfere with new connections
      - The final ACK has time to reach the peer
      This is why you might see 'Address already in use' when restarting a server.

  - id: q15
    type: multiple_choice
    lo_ref: LO7
    bloom_level: apply
    difficulty: intermediate
    points: 1
    stem: "In Wireshark, which filter shows only TCP packets with the SYN flag set?"
    options:
      a: "tcp.syn"
      b: "tcp.flags.syn == 1"
      c: "tcp contains SYN"
      d: "filter.tcp.syn"
    correct: b
    explanation: |
      Wireshark display filters use dot notation for protocol fields.
      tcp.flags.syn == 1 filters packets where the SYN flag is set (value 1).
      This shows both SYN (connection initiation) and SYN-ACK packets.
      To see only pure SYN: tcp.flags.syn == 1 && tcp.flags.ack == 0

  # ═══════════════════════════════════════════════════════════════════════════
  # COMPREHENSIVE REVIEW — LO3, LO4, LO5, LO7 Coverage
  # ═══════════════════════════════════════════════════════════════════════════

  - id: q16
    type: multiple_choice
    lo_ref: LO3
    bloom_level: understand
    difficulty: intermediate
    points: 1
    stem: "When parsing a CSV file with network data, which Python module is most appropriate for handling comma-separated values with proper quoting?"
    options:
      a: "The re module with regex patterns"
      b: "The csv module from the standard library"
      c: "The json module with custom parsing"
      d: "The str.split(',') method directly"
    correct: b
    explanation: |
      The csv module handles edge cases like quoted fields containing commas,
      escaped quotes and different delimiters. Using str.split(',') breaks
      when data contains commas within quoted fields.
    feedback:
      correct: "Correct! The csv module properly handles quoting and escaping."
      incorrect: "The csv module is designed specifically for this purpose and handles edge cases."

  - id: q17
    type: fill_blank
    lo_ref: LO3
    bloom_level: apply
    difficulty: intermediate
    points: 1
    stem: "To extract an IP address from a string using Python regex, each octet pattern is: \\d{1,_}"
    correct: ["3"]
    case_sensitive: false
    explanation: "Each octet of an IPv4 address is 1-3 digits (0-255). The pattern \\d{1,3} matches this."
    hint: "Think about the maximum number of digits in an IP octet (e.g. 255)"

  - id: q18
    type: numeric
    lo_ref: LO5
    bloom_level: apply
    difficulty: intermediate
    points: 2
    stem: "Calculate the transmission delay (in milliseconds) for sending a 1500-byte packet over a 100 Mbps link. Round to 2 decimal places."
    correct: 0.12
    tolerance: 0.01
    explanation: |
      Transmission delay = Packet size / Bandwidth
      = (1500 bytes x 8 bits/byte) / (100 x 10^6 bits/second)
      = 12000 / 100,000,000
      = 0.00012 seconds
      = 0.12 milliseconds
    hint: "Remember to convert bytes to bits (multiply by 8)"
    show_work: true

  - id: q19
    type: multiple_choice
    lo_ref: LO5
    bloom_level: understand
    difficulty: basic
    points: 1
    stem: "Which component of end-to-end delay is affected by the LENGTH of the physical link?"
    options:
      a: "Transmission delay"
      b: "Propagation delay"
      c: "Processing delay"
      d: "Queuing delay"
    correct: b
    explanation: |
      Propagation delay = Distance / Speed of light in medium

      Longer physical links mean light/electrical signals travel further,
      increasing propagation delay. Transmission delay depends on packet
      size and bandwidth, not distance.
    misconception_ref: "docs/misconceptions.md#misconception-1"
    feedback:
      correct: "Correct! Propagation delay is distance-dependent."
      incorrect: "Remember: propagation = distance/speed, transmission = size/bandwidth"

  - id: q20
    type: multiple_choice
    lo_ref: LO7
    bloom_level: remember
    difficulty: basic
    points: 1
    stem: "In Wireshark, which interface should you select to capture traffic from Docker containers running in WSL2?"
    options:
      a: "Ethernet (physical adapter)"
      b: "Wi-Fi (wireless adapter)"
      c: "vEthernet (WSL)"
      d: "Loopback Adapter"
    correct: c
    explanation: |
      Docker containers in WSL2 communicate through the virtual Ethernet
      adapter that bridges WSL2 and Windows. The vEthernet (WSL) interface
      captures this traffic. Physical adapters capture external network
      traffic, not internal Docker communication.
    related_doc: "../README.md#wireshark-setup-and-usage"
    feedback:
      correct: "Correct! vEthernet (WSL) captures WSL2/Docker traffic."
      incorrect: "For Docker in WSL2, use vEthernet (WSL), not physical adapters."

  - id: q21
    type: fill_blank
    lo_ref: LO7
    bloom_level: apply
    difficulty: intermediate
    points: 1
    stem: "To filter Wireshark display to show only TCP packets on port 9090, you would type: tcp.port == _____"
    correct: ["9090"]
    case_sensitive: false
    explanation: "tcp.port matches both source and destination port. For specific direction, use tcp.srcport or tcp.dstport."
    hint: "The display filter uses the format: protocol.field == value"

  - id: q22
    type: multiple_choice
    lo_ref: LO4
    bloom_level: analyse
    difficulty: advanced
    points: 2
    stem: "When analysing a PCAP file, you see a packet sequence: SYN, SYN-ACK, RST. What does this indicate?"
    options:
      a: "Successful connection followed by graceful close"
      b: "Connection refused - server rejected the connection"
      c: "Connection timeout - no response from server"
      d: "Packet corruption - invalid checksum detected"
    correct: b
    explanation: |
      The RST (Reset) flag after SYN-ACK typically indicates:
      - The destination port is closed
      - A firewall is blocking the connection
      - The application crashed between SYN-ACK and connection establishment

      A graceful close would show FIN packets, not RST.
    feedback:
      correct: "Excellent analysis! RST after handshake start indicates rejection."
      incorrect: "RST indicates connection reset/refusal, not timeout or corruption."
